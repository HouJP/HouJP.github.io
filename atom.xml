<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>#include&amp;lt;AI&amp;gt;</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houjp.com/"/>
  <updated>2018-04-15T09:43:03.995Z</updated>
  <id>http://houjp.com/</id>
  
  <author>
    <name>HouJP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Recurrent Neural Networks / Week 2</title>
    <link href="http://houjp.com/2018/04/15/rnn-w2/"/>
    <id>http://houjp.com/2018/04/15/rnn-w2/</id>
    <published>2018-04-14T23:17:30.000Z</published>
    <updated>2018-04-15T09:43:03.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Word-Representation"><a href="#Word-Representation" class="headerlink" title="Word Representation"></a>Word Representation</h3><p>One hot编码有天然的劣势，比如，</p>
<ul>
<li>I want a glass of orange <u>juice</u>.</li>
<li>I want a glass of apple <u>juice</u>.</li>
</ul>
<p>如果我们从上面一句学到了orange后边是juice，是无法推断出来第二句的填空题中apple后边应该填juice。因为在One hot编码中，orange和apple两个向量之间没有任何的关联关系。因此，我们需要Word representation来对词进行表达，而不是用One hot编码。</p>
<a id="more"></a>
<h3 id="Transfer-Learning-and-Word-Embeddings"><a href="#Transfer-Learning-and-Word-Embeddings" class="headerlink" title="Transfer Learning and Word Embeddings"></a>Transfer Learning and Word Embeddings</h3><ol>
<li><p>Learn word embeddings from large text corpus. (1-100B words)</p>
<p>(Or download pre-trained embedding online.)</p>
</li>
<li><p>Transfer embedding to new task with smaller training set. (Say, 100k words)</p>
</li>
<li><p>Optional: Continue to finetune the word embeddings with new data.</p>
</li>
</ol>
<h3 id="Relation-to-Face-Encoding"><a href="#Relation-to-Face-Encoding" class="headerlink" title="Relation to Face Encoding"></a>Relation to Face Encoding</h3><p>在Face encoding中，人脸图像的输入可以是任意一张图像，经过CNN之后可以变成向量的表达，这个过程叫做Encoding。而对于Word embedding来说，我们的词表是固定的，在WE模型训练的过程中决定了我们对哪些words进行表达学习。</p>
<h3 id="Properties-of-Word-Embeddings"><a href="#Properties-of-Word-Embeddings" class="headerlink" title="Properties of Word Embeddings"></a>Properties of Word Embeddings</h3><p>Word embedding有一些有趣的性质，比如，<br>$$<br>e _ { man } - e _ { woman } \approx e _ { king } - e _ { queen }<br>$$</p>
<h3 id="Embedding-Matrix"><a href="#Embedding-Matrix" class="headerlink" title="Embedding Matrix"></a>Embedding Matrix</h3><p>假设Embedding matrix是$m\times n$的矩阵，其中$m$是embedding的维度，$n$是词表的大小，第$j$个词的embedding必到可以通过Embedding matrix与该词One-hot编码（$shape=n\times1$）相乘得到，<br>$$<br>E~o_j = e_j<br>$$<br>当然实际运算中不会这么计算，效率太低了。</p>
<h3 id="Word2Vec之Skip-gram-Model"><a href="#Word2Vec之Skip-gram-Model" class="headerlink" title="Word2Vec之Skip-gram Model"></a>Word2Vec之Skip-gram Model</h3><p>Skip-gram的思想是在句子中随机摘取一个词作为context，再在这个词的上下文中（一定长度的窗口）中随机摘取另一个词作为target，训练如下的神经网络结构，<br>$$<br>o_c \rightarrow Embedding~Layer \rightarrow e_c \rightarrow Softmax~Layer \rightarrow \hat{y}<br>$$<br>Softmax layer的概率预测如下所示，<br>$$<br>Softmax:~p(t|c) = \frac{e^{\theta_{t}^{T}e_c}}{\sum_{j=1}^{Vocab~size} e^{\theta_{j}^{T}e_c}}<br>\tag{1}<br>$$<br>其中，$\theta<span class="md-search-hit">_</span>t$表示与目标词One-hot向量第$t$维有关的参数向量。</p>
<p>Loss function如下，<br>$$<br>\mathcal{L}(\hat{y}, y) = - \sum_{i=1}^{Vocab~size} y_i \log \hat{y}_i<br>$$<br>但是在式(1)的计算中，计算量是很大的（需要遍历词表），所以采用Hierarchical softmax来计算给定context:c的情况下target:t出现的概率，而不是采用普通的Softmax classification方法。</p>
<blockquote>
<p><a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="external">word2vec 中的数学原理详解（四）基于 Hierarchical Softmax 的模型</a></p>
</blockquote>
<p>Word2Vec有两个版本，Skip-gram和CBOW。</p>
<h3 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h3><p>首先定义一个监督学习问题，给定一个词对$&lt; c, t &gt;$，并对该词对进行二分类。这个问题的正样本可以通过上一小节中介绍的方法得到，然后根据每个正样本可以通过随机采样词表的方式来得到$k$条负样本。这样，针对一个词对，我们可以计算词对为正样本的概率，<br>$$<br>p(y=1 | c,t) = \delta(\theta_t^{T} e_c)<br>$$<br>构造如下结构的网络，<br>$$<br>o_c \rightarrow Embedding~Layer \rightarrow e_c \rightarrow Vocab~size \times Logistic~Unit<br>$$<br>这样，针对每个样本，我们只需要从Vocab size个Logistic Unit中选择target:t所对应的那个二分类器去更新参数就好了，这样极大的减少了计算量。</p>
<h3 id="GloVe-Word-Vectors"><a href="#GloVe-Word-Vectors" class="headerlink" title="GloVe Word Vectors"></a>GloVe Word Vectors</h3><p>Glove Word Vectors的目的是给定一个词对$&lt; c, t &gt;$，来进行一个回归问题，预测目标词t在c的上下文中出现的次数。它的优化目标是，<br>$$<br>minimize \sum_{i=1}^{Vocab~size} \sum_{j=1}^{Vocab~size} f(x_{ii}) (\theta_i^T e_j + b_i + b_j’ - \log x_{ij})^2<br>$$<br>其中，$i, j$分别表示$t, c$在词表中的编号，$x<em>{ij}$表示$t$在$c$的上下文中出现的次数。$f(x</em>{ij})$是weight function，当$x<em>{ij}=0$的时候，$f(x</em>{ij})=0$。</p>
<p>在这个式子中，我们可以发现，$\theta_i$与$e_j$是对称的，所以，<br>$$<br>e_w^{final} = \frac{e_w + \theta_w}{2}<br>$$</p>
<h3 id="Debiasing-Word-Embeddings"><a href="#Debiasing-Word-Embeddings" class="headerlink" title="Debiasing Word Embeddings"></a>Debiasing Word Embeddings</h3><p>无关主题的话，在上NG的课的时候，听到NG介绍了一些人的工作，比如说给你一幅油画，怎么把照片变成油画的风格，再比如有的人会去研究word embedding中的歧视现象（性别、种族等），发现这些人都好有意思啊，老外们不一样的科研。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Word-Representation&quot;&gt;&lt;a href=&quot;#Word-Representation&quot; class=&quot;headerlink&quot; title=&quot;Word Representation&quot;&gt;&lt;/a&gt;Word Representation&lt;/h3&gt;&lt;p&gt;One hot编码有天然的劣势，比如，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I want a glass of orange &lt;u&gt;juice&lt;/u&gt;.&lt;/li&gt;
&lt;li&gt;I want a glass of apple &lt;u&gt;juice&lt;/u&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们从上面一句学到了orange后边是juice，是无法推断出来第二句的填空题中apple后边应该填juice。因为在One hot编码中，orange和apple两个向量之间没有任何的关联关系。因此，我们需要Word representation来对词进行表达，而不是用One hot编码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="rnn" scheme="http://houjp.com/tags/rnn/"/>
    
  </entry>
  
  <entry>
    <title>Recurrent Neural Networks / Week 1</title>
    <link href="http://houjp.com/2018/04/08/rnn-w1/"/>
    <id>http://houjp.com/2018/04/08/rnn-w1/</id>
    <published>2018-04-07T23:17:30.000Z</published>
    <updated>2018-04-14T12:37:27.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Why-not-a-standard-network"><a href="#Why-not-a-standard-network" class="headerlink" title="Why not a standard network"></a>Why not a standard network</h3><p>传统网络不可行的原因，</p>
<ol>
<li>Inputs, outputs can be different lengths in different examples.</li>
<li>Doesn’t share features learned across different positions of text.</li>
</ol>
<p>RNN的网络结构如下所示，</p>
<p><img src="/img/rnn-w1/rnn.jpeg" width="70%" align="center"></p>
<a id="more"></a>
<p>形式化描述如下，<br>$$<br>a^{&lt; t &gt;} = g<em>1 ( W</em>{aa} a^{&lt; t - 1&gt;} + W_{ax} x^{&lt; t &gt;} + b_a) \\<br>\hat{y}^{&lt; t &gt;} = g<em>2 ( W</em>{ya} a^{&lt; t &gt;} + b<em>y )<br>$$<br>其中，$W</em>{ax}$中的角标表示的是输出和输入。</p>
<p>为了简单起见，改写为如下形式，<br>$$<br>a^{&lt; t &gt;} = g_1 (W_a [a^{&lt; t - 1 &gt;}, x^{&lt; t &gt;}] + b_a) \\<br>\hat{y}^{&lt; t &gt;} = g_2 (W_y a^{&lt; t &gt;} + b_y)<br>$$<br>其中，$W<em>a$由$W</em>{aa}$和$W_{ax}$水平拼接而成，$[a^{&lt; t - 1 &gt;}, x^{&lt; t &gt;}]$表示两者的垂直拼接。</p>
<h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><p>针对命名实体识别问题，定义单个句子上某个输出位置的损失函数，<br>$$<br>\mathcal{L}^{&lt; t &gt;} (\hat{y}^{&lt; t &gt;}, y^{&lt; t &gt;}) = - y^{&lt; t &gt;} \log \hat{y}^{&lt; t &gt;} - (1 - y^{&lt; t &gt;}) \log (1 - \hat{y}^{&lt; t &gt;})<br>$$<br>那么，整个句子上的损失函数为，<br>$$<br>\mathcal{L}(\hat{y}, y) = \sum_{t=1}^{T_y} \mathcal{L}^{&lt; t &gt;} (\hat{y}^{&lt; t &gt;}, y^{&lt; t &gt;})<br>$$</p>
<h3 id="Word-level-VS-Character-level-Language-Model"><a href="#Word-level-VS-Character-level-Language-Model" class="headerlink" title="Word-level VS. Character-level Language Model"></a>Word-level VS. Character-level Language Model</h3><p>使用字符级别的语言模型，可以不用关心unknown word tokens。但是缺点也很明显，</p>
<ol>
<li>很多情况下效果不如词级别的语言模型，因为模型更深，导致句子靠前位置的信息丢失严重。</li>
<li>因为(1)的原因，导致更消耗计算资源。</li>
</ol>
<h3 id="Gated-Recurrent-Unit-GRU"><a href="#Gated-Recurrent-Unit-GRU" class="headerlink" title="Gated Recurrent Unit (GRU)"></a>Gated Recurrent Unit (GRU)</h3><p>在GRU中引入了一个新的概念memory cell来替代原先的activations（在GRU中，这两个东西是等价的，而在LSTM中不等价），我们用$c^{&lt; t &gt;}$来表示memory cell。下面对GRU进行形式化表述，<br>$$<br>\begin{split}<br>&amp; \tilde{c}^{&lt; t &gt;} = \tanh( W_{c} [ \Gamma_r \ast c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;}] + b<em>c ) \\<br>&amp; \Gamma</em>{u} = \delta ( W_u [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;} ] + b<em>u ) \\<br>&amp; \Gamma</em>{r} = \delta ( W_r [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;} ] + b<em>r ) \\<br>&amp; c^{&lt; t &gt;} =  \Gamma</em>{u} \ast \tilde{c}^{&lt; t &gt;} + ( 1 - \Gamma_{u} ) \ast c^{&lt; t - 1 &gt;} \\<br>&amp; a^{ &lt; t &gt;} = c^{&lt; t &gt;}<br>\end{split}<br>$$<br>其中，$\delta$表示sigmoid函数，$\Gamma_u$是与$ \tilde{c}^{&lt; t &gt;} $长度相同的向量。$\tilde{c}^{&lt; t &gt;}$ 是$c^{&lt; t &gt;}$的候选， $\Gamma_u$表示的是update gate，代表对新旧memory cell的中和取舍，可以很有效的解决vanishing gradients问题。因为 $\Gamma_u$中的元素很容易因为学习而得到一个接近0的数值（sigmoid函数，当自变量是一个很大的负数的时候），所以在更新得到$c^{&lt; t &gt;}$时，第一项会成为一个很小的可以忽略的项，而让$c^{&lt; t &gt;}$接近$c^{&lt; t - 1 &gt;}$。</p>
<p>$\Gamma_r$表示的是relavant gate，代表候选$\tilde{c}^{&lt; t &gt;}$与上一时刻的memory cell的相关度。</p>
<h3 id="Long-Short-Term-Memory"><a href="#Long-Short-Term-Memory" class="headerlink" title="Long Short Term Memory"></a>Long Short Term Memory</h3><p>LSTM是GRU的增强版本。形式化描述如下，<br>$$<br>\begin{split}<br>&amp; \tilde{c}^{&lt; t &gt;} = \tanh( W_{c} [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;}] + b<em>c ) \\<br>Update:~&amp; \Gamma</em>{u} = \delta ( W_u [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;} ] + b<em>u ) \\<br>Forget:~&amp; \Gamma</em>{f} = \delta ( W_f [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;} ] + b<em>f ) \\<br>Output:~&amp; \Gamma</em>{o} = \delta ( W_o [ c^{&lt; t - 1 &gt;}, x^{&lt; t &gt;} ] + b<em>o ) \\<br>&amp; c^{&lt; t &gt;} =  \Gamma</em>{u} \ast \tilde{c}^{&lt; t &gt;} +  \Gamma<em>{f}  \ast c^{&lt; t - 1 &gt;} \\<br>&amp; a^{ &lt; t &gt;} = \Gamma</em>{o} \ast \tanh c^{&lt; t &gt;}<br>\end{split}<br>$$</p>
<h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><p>Bi-RNN的出现是因为在预测时候，我们只能看到历史的信息而不能看到未来的信息。为了解决这个问题，Bi-RNN采用了双RNN结构，其中一个RNN的信息从左向右流动，另一个RNN的信息从右向左流动，在预测/输出的时候，会同时考虑到两个RNN结构的输出结果，也就是，<br>$$<br>\hat{y}^{&lt; t &gt;} = g(W_y [a^{\rightarrow &lt; t &gt;}, a^{ \leftarrow &lt; t &gt;}] + b_y)<br>$$<br>其中，$g$表示activation function。</p>
<h3 id="Deep-RNNs"><a href="#Deep-RNNs" class="headerlink" title="Deep RNNs"></a>Deep RNNs</h3><p>Deep RNNs的目的是将若干单层RNN的结构叠加起来构造一个深层的RNN结构。不过在实际中，Deep RNNs网络的深度一般不会超过三层。举例来说明如何堆叠RNNs，<br>$$<br>a^{ [2] &lt; 3 &gt; } = g( W_a^{[2]} [ a^{[2]&lt; 2 &gt;}, a^{[1] &lt; 3 &gt;} ] + b_a^{[2]} )<br>$$<br>其中，$a^{ [2] &lt; 3 &gt; } $表示第2层在$t_3$时刻的activations。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Why-not-a-standard-network&quot;&gt;&lt;a href=&quot;#Why-not-a-standard-network&quot; class=&quot;headerlink&quot; title=&quot;Why not a standard network&quot;&gt;&lt;/a&gt;Why not a standard network&lt;/h3&gt;&lt;p&gt;传统网络不可行的原因，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Inputs, outputs can be different lengths in different examples.&lt;/li&gt;
&lt;li&gt;Doesn’t share features learned across different positions of text.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RNN的网络结构如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/rnn-w1/rnn.jpeg&quot; width=&quot;70%&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="rnn" scheme="http://houjp.com/tags/rnn/"/>
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 4</title>
    <link href="http://houjp.com/2018/04/06/cnn-w4/"/>
    <id>http://houjp.com/2018/04/06/cnn-w4/</id>
    <published>2018-04-06T14:40:27.000Z</published>
    <updated>2018-04-14T12:37:27.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-Face-Recognition"><a href="#What-is-Face-Recognition" class="headerlink" title="What is Face Recognition"></a>What is Face Recognition</h3><p>这里区分两个概念，<code>Face verification</code>和<code>Face recognition</code>，</p>
<ul>
<li>Verification<ul>
<li>输入：图像 + 名字/ID</li>
<li>输出：输入的图像上是否有名字/ID表示的那个人</li>
</ul>
</li>
<li>Recognition<ul>
<li>数据库中有$K$个人</li>
<li>输入：图像</li>
<li>输出：图像上有的数据库中的人的名字/ID</li>
</ul>
</li>
</ul>
<p>很明显，Recognition比Verification的难度要大得多。</p>
<a id="more"></a>
<h3 id="One-Shot-Learning"><a href="#One-Shot-Learning" class="headerlink" title="One Shot Learning"></a>One Shot Learning</h3><p>什么是One-shot learning，</p>
<blockquote>
<p>Learning from one example to recognize the person again.</p>
</blockquote>
<p>很多时候公司的数据库中只有一张员工的照片，那么我们在做人脸识别系统的时候怎么根据这一张照片来再次识别相同的人的影像？如果用传统的卷积神经网络来做的话，因为训练数据很小，所以通常效果并不理想。</p>
<p>在这种情况下，我们应该学习”similarity” function,<br>$$<br>d(img1, img2) = degree~of~difference~between~images<br>$$<br>然后可以根据Similarity function完成verification,<br>$$<br>\begin{split}<br>If~d(img1, img2) &amp;\le \tau~same\\<br>&amp;&gt; \tau~different<br>\end{split}<br>$$</p>
<h3 id="Siamese-Network"><a href="#Siamese-Network" class="headerlink" title="Siamese Network"></a>Siamese Network</h3><p>Parameters of NN define an encoding $f(x^{(i)})$</p>
<p>Learn parameters so that:</p>
<ul>
<li>If $x^{(i)}, x^{(j)}$ are the same person, $| f(x^{(i)}) - f(x^{(j)}) |^2$ is small</li>
<li>If $x^{(i)}, x^{(j)}$ are the different person, $| f(x^{(i)}) - f(x^{(j)}) |^2$ is large</li>
</ul>
<p>那么，该网络学习的目标函数应该怎么定义呢？</p>
<h3 id="Triple-Loss"><a href="#Triple-Loss" class="headerlink" title="Triple Loss"></a>Triple Loss</h3><p>在Triple loss中，基准人脸图像称为Anchor image，正样本为Positive image，负样本为Negative image，那么我们希望得到的是，<br>$$<br>|f(A) - f(P) | ^2 \le | f(A) - f(N) | ^2<br>$$<br>也就是，<br>$$<br>|f(A) - f(P) | ^2 - | f(A) - f(N) | ^2 \le 0<br>$$<br>这里有个问题，如果$f$始终预测0，那么上述条件始终满足。为了防止这种情况发生，所以需要增加一个超参$\alpha$，也称为margin，<br>$$<br>|f(A) - f(P) | ^2 - | f(A) - f(N) | ^2 + \alpha \le 0<br>$$<br>下面对Loss function进行形式化定义，给定3个图像 A, P, N，<br>$$<br>\mathcal{L}(A, P, N) = max(|f(A) - f(P)|^2 -|f(A) - f(N)|^2  + \alpha, 0)<br>$$<br>在整体样本上的损失为，<br>$$<br>J = \sum_{i=1}^{M} \mathcal{L}(A^{(i)}, P^{(i)}, N^{(i)})<br>$$<br>很明显，在训练样本中，一个人需要有多张照片才能组合出这样的三元组。</p>
<p>那么，应该怎么选择三元组呢，</p>
<ul>
<li>During training, if A, P, N are chsen randomly, $d(A, P) + \alpha \le d(A, N)$ is easily satisfied.<ul>
<li>这种方法容易选择，但是训练出来的模型效果一般</li>
</ul>
</li>
<li>Choose triplets that’re “hard” to train on.<ul>
<li>这种方法不容易选择，但是模型能学习到更多的信息。</li>
</ul>
</li>
</ul>
<h3 id="Face-Verification-and-Binary-Classification"><a href="#Face-Verification-and-Binary-Classification" class="headerlink" title="Face Verification and Binary Classification"></a>Face Verification and Binary Classification</h3><p>另一种similarity function，以一对图像作为输入，<br>$$<br>\hat{y} = \delta ( \sum_{k=1}^{128} w_i | f(x^{(i)})_k - f(x^{(j)})_k   | + b  )<br>$$<br>其中，$f(x^{(i)})$表示对第i张图像的128维的embedding表达。</p>
<h3 id="What-are-deep-ConvNets-Learning"><a href="#What-are-deep-ConvNets-Learning" class="headerlink" title="What are deep ConvNets Learning"></a>What are deep ConvNets Learning</h3><p>这里介绍了怎么将卷积神经网络的hidden layer可视化。以第一层为例，</p>
<blockquote>
<p>Pick a unit in layer 1. Find the nine image patches that maximize the unit’s activation.</p>
<p>Repeat for other units.</p>
</blockquote>
<p>可以看到，每个unit’s activation针对的方向不同，有的是颜色，有的是不同方向的边。随着网络深度的增加，每个unit’s activation可以看到的图像的范围越来越大。 </p>
<h3 id="Neural-Style-Transfer-Cost-Function"><a href="#Neural-Style-Transfer-Cost-Function" class="headerlink" title="Neural Style Transfer Cost Function"></a>Neural Style Transfer Cost Function</h3><p>原始内容图片为C，风格图片为S，目标图片为G，那么，<br>$$<br>J(G) = \alpha J<em>{content}(C, G) + \beta J</em>{style}(S, G)<br>$$<br>下面介绍Style matrix,<br>$$<br>\begin{split}<br>&amp; Let~a_{i,j,k}^{[l]} &amp;= activation~at~(i,j,k). G^{[l]}~is~n_c^{[l]} \times n<em>c^{[l]} \\<br>\rightarrow &amp; G</em>{kk’}^{[l]} &amp;= \sum_{i=1}^{n<em>H^{[l]}} \sum</em>{j=1}^{[n<em>W]^{[l]}} a</em>{ijk}^{[l]} a_{ijk’}^{[l]}<br>\end{split}<br>$$<br>其中，$G^{[l]}$为Style matrix。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-Face-Recognition&quot;&gt;&lt;a href=&quot;#What-is-Face-Recognition&quot; class=&quot;headerlink&quot; title=&quot;What is Face Recognition&quot;&gt;&lt;/a&gt;What is Face Recognition&lt;/h3&gt;&lt;p&gt;这里区分两个概念，&lt;code&gt;Face verification&lt;/code&gt;和&lt;code&gt;Face recognition&lt;/code&gt;，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification&lt;ul&gt;
&lt;li&gt;输入：图像 + 名字/ID&lt;/li&gt;
&lt;li&gt;输出：输入的图像上是否有名字/ID表示的那个人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Recognition&lt;ul&gt;
&lt;li&gt;数据库中有$K$个人&lt;/li&gt;
&lt;li&gt;输入：图像&lt;/li&gt;
&lt;li&gt;输出：图像上有的数据库中的人的名字/ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很明显，Recognition比Verification的难度要大得多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="http://houjp.com/tags/cnn/"/>
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 3</title>
    <link href="http://houjp.com/2018/04/06/cnn-w3/"/>
    <id>http://houjp.com/2018/04/06/cnn-w3/</id>
    <published>2018-04-06T03:24:21.000Z</published>
    <updated>2018-04-14T12:37:27.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-Localization"><a href="#Object-Localization" class="headerlink" title="Object Localization"></a>Object Localization</h3><p>Object localization用来识别图像中是否包含特定对象以及该对象的位置，并最终使用一个矩形框在图像中标出该特定对象。为了简化问题，在这里我们假设图片中最多包含一个待识别的对象。下面对问题进行形式化描述。</p>
<p>定义目标变量$y$ (同时也是神经网络的输出层)，<br>$$<br>y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T<br>\tag{1}<br>$$<br><a id="more"></a></p>
<p>其中，$P_c$表示图像中是否包含特定对象，$(b_x, b_y)$表示特定对象的中心位置在图像中的坐标（图像左上角坐标为$(0,0)$，右下角坐标为$(1,1)$），$b_h,b_w$分别表示特定对象的高度和宽度，$C_1-C_3$表示特定对象的类型（行人，汽车，摩托车）。</p>
<p>定义损失函数$\mathcal{L(\hat{y}, y)}$，<br>$$<br>\mathcal{L}(\hat{y}, y) =<br>\begin{split}<br>\begin{cases}<br>\sum_{i=1}^{i=8} (\hat{y}_i - y_i)^2,&amp;~if~y_1=1 \\<br>(\hat{y}_1 - y_1)^2,&amp;~if~y_1=0<br>\end{cases}<br>\end{split}<br>$$<br>这里针对不同的维度都使用了平方差损失函数，可以针对不同的维度使用不同的损失函数。</p>
<h3 id="Landmark-Detection"><a href="#Landmark-Detection" class="headerlink" title="Landmark Detection"></a>Landmark Detection</h3><p> 有时候我们需要识别图中的一些关键点的坐标，这些坐标称为Landmarks。这时候，我们可以定义如下的目标变量$y$，<br>$$<br>y = [P~l<em>{1x}~l</em>{1y}~\dots~l<em>{nx}~l</em>{ny}]^T<br>$$<br>以识别人面部眼角嘴角为例，其中$P$代表是否包含人脸，$(l<em>{ix}, l</em>{iy})$代表关键点的坐标。</p>
<h3 id="Object-Detection"><a href="#Object-Detection" class="headerlink" title="Object Detection"></a>Object Detection</h3><p> Object Detction的其中一种办法叫做Sliding windows detection，采用不同尺寸的矩形框，从左至右、从上到下遍历枚举图像的子图，判断子图中是否包含需要的目标对象。很明显，这种办法比较笨，需要消耗大量的计算量。</p>
<h3 id="Convolutional-Implementation-of-Sliding-Windows"><a href="#Convolutional-Implementation-of-Sliding-Windows" class="headerlink" title="Convolutional Implementation of Sliding Windows"></a>Convolutional Implementation of Sliding Windows</h3><p>全连接是可以通过卷积来实现的，并且两者直接是等价的。例如，如果$5\times 5 \times 16$的卷积层之后接的是一个$400$个神经元的全连接层，那么它等价于$5 \times 5 \times 16$的卷积层之后采用400个$5 \times 5 \times 16$的filters得到的$1 \times 1 \times 400$的卷积层。</p>
<p>得益于卷积的存在，Sliding windows detection可以做到同时预测同一张图像不同子图中是否包含特定对象。但是这样做的不利条件是预测出来的对象的边界（bounding box）会相对不准确。因为这种办法采用的是子图的边界来作为待预测对象的边界。 </p>
<h3 id="Bounding-Box-Predictions"><a href="#Bounding-Box-Predictions" class="headerlink" title="Bounding Box Predictions"></a>Bounding Box Predictions</h3><p>这里介绍了YOLO algorithm (You Only Look Once)，该算法用来识别同一张图像上的多个目标简单。它将图像切分为了$M \times N$的网格并在此基础上构造了卷积神经网络。该网络的输入依然为整张图片，切分并不影响输入，而是决定了网络的输出尺寸为$M \times N \times 8$。这样，每个子图就拥有了一个$1 \times 1 \times 8$的预测结果，用来表示图像中是否包含特定的对象，如果包含的话，该特定对象的中心位置、长宽以及类别分别是什么。</p>
<p>该算法利用了卷积操作提高了对同一张图像上不同子图的模型训练预测的效率，使得一次训练就可以完成对多个子图的建模（这里有个假设，就是每个子图上只包含最多一个特定对象）。</p>
<h3 id="Intersection-Over-Union"><a href="#Intersection-Over-Union" class="headerlink" title="Intersection Over Union"></a>Intersection Over Union</h3><p>$$<br>Intersection over Union (loU) = \frac{size~of~intersection}{size~of~union}<br>$$</p>
<p>通过loU，我们可以知道两个矩形在大小和位置上的相像程度。这样，我们就可以用它来评价object detection算法的优劣。</p>
<h3 id="Non-max-Suppression"><a href="#Non-max-Suppression" class="headerlink" title="Non-max Suppression"></a>Non-max Suppression</h3><p>有时候，我们的算法会将相同的对象识别多次，non-max suppression算法用来解决这个问题。举例，</p>
<p>假设卷积神经网络最后的输出为$19 \times 19 \times 5$，也就是说图像被切分为了$19 \times 19$的子图，每个子图的预测结果为一个5维的向量，该向量如下，<br>$$<br>y = [p_c~b_x~b_y~b_h~b_w]^T<br>$$<br>那么，在训练结束之后，non-max suppression算法会执行如下步骤，</p>
<ol>
<li>扔掉所有$p_c \le 0.6$的bounding boxes</li>
<li>取出剩余bounding boxes中$p_c$最大的那个bounding box，作为新检测到的目标</li>
<li>删除剩余所有与该box的loU值$\ge 0.5$的bounding boxes</li>
<li>重复(2-3)步，直到没有bounding boxes剩余</li>
</ol>
<p>从上可以看出，non-max suppression其实是个简单的贪心算法。</p>
<h3 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h3><p>在Object detection问题中，还有一个难点就是图像划分出网格后，每个网格中只能最多识别一个对象。为了让单个网格识别多个对象，可以采用Anchor boxes方法。</p>
<p>Anchor boxes方法的思想很简单，将式(1)改为如下形式，<br>$$<br>y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3~P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T<br>\tag{2}<br>$$<br>式(2)表示在识别的过程中采用了两个Anchor box。每个Anchor box都负责识别所有类别的对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object-Localization&quot;&gt;&lt;a href=&quot;#Object-Localization&quot; class=&quot;headerlink&quot; title=&quot;Object Localization&quot;&gt;&lt;/a&gt;Object Localization&lt;/h3&gt;&lt;p&gt;Object localization用来识别图像中是否包含特定对象以及该对象的位置，并最终使用一个矩形框在图像中标出该特定对象。为了简化问题，在这里我们假设图片中最多包含一个待识别的对象。下面对问题进行形式化描述。&lt;/p&gt;
&lt;p&gt;定义目标变量$y$ (同时也是神经网络的输出层)，&lt;br&gt;$$&lt;br&gt;y = [P_c~b_x~b_y~b_h~b_w~C_1~C_2~C_3]^T&lt;br&gt;\tag{1}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="http://houjp.com/tags/cnn/"/>
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 2</title>
    <link href="http://houjp.com/2018/04/02/cnn-w2/"/>
    <id>http://houjp.com/2018/04/02/cnn-w2/</id>
    <published>2018-04-02T12:50:35.000Z</published>
    <updated>2018-04-14T12:37:27.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Classic-Networks"><a href="#Classic-Networks" class="headerlink" title="Classic Networks"></a>Classic Networks</h3><p>LeNet-5的网络结构如下，</p>
<p><img src="/img/cnn-w2/lenet-5.jpeg" width="80%" align="center"></p>
<a id="more"></a>
<p>AlexNet的网络结构如下，</p>
<p><img src="/img/cnn-w2/alexnet.jpeg" width="80%" align="center"></p>
<p>VGG-16的网络结构如下，</p>
<p><img src="/img/cnn-w2/vgg-16.jpeg" width="80%" align="center"></p>
<h3 id="ResNets"><a href="#ResNets" class="headerlink" title="ResNets"></a>ResNets</h3><p>在一般的神经网络中，两层神经网络的数学表达如下，<br>$$<br>\begin{split}<br>&amp; z^{[l+1]} = W^{[l+1]}a^{[l]} + b^{[l+1]} \\<br>&amp; a^{[l+1]} = g(z^{[l+1]}) \\<br>&amp; z^{[l+2]} = W^{[l+2]}a^{[l + 1]} + b^{[l+2]} \\<br>&amp; a^{[l+2]} = g(z^{[l+2]})<br>\end{split}<br>$$<br>而在ResNets中，修改了$a^{[l+2]}$的生成方式，变成了，<br>$$<br>a^{[l+2]} = g(z^{[l + 2]} + a^{[l]})<br>\tag{1}<br>$$<br>这样的两层神经网络称为Residual block，将这样的Residual block串联起来就构成了ResNets。</p>
<p>ResNets解决了传统神经网络中存在的层数不能过深的问题。在传统的神经网络中，随着深度的增加，训练误差会先降后升，而对于ResNets，随着网络层数达到一百甚至一千层，训练误差也可以平缓的下降（也可能出现收敛的现象）。</p>
<h3 id="Why-ResNets-Work"><a href="#Why-ResNets-Work" class="headerlink" title="Why ResNets Work"></a>Why ResNets Work</h3><p>首先来解释一下为什么在传统的网络后面加一个Residual block不会降低原有网络的性能，<br>$$<br>\begin{split}<br>a^{[l+2]} &amp;= g(z^{[l + 2]} + a^{[l]}) \\<br>    &amp;= g((w^{[l+2]}a^{[l + 1]} + b^{[l + 2]}) + a^{[l]})<br>\end{split}<br>$$<br>假设我们采用的激活函数为RELU，同时$w^{[l+2]}$和$b^{[l+2]}$为0，那么，<br>$$<br>a^{[l+2]} = g(a^{[l]}) = a^{[l]}<br>$$<br>所以由于Residual block的存在，网络在第$l+2$层的时候，很容易退回到$l$层去。这样可以达到一个效果，在最差情况下，后边加上的Residual block仿佛不存在一样，这样就不会影响原先的效果。</p>
<p>Residual block中还有一点值得注意，对于式(1)来说，$z^{[l+2]}$和$a^{[l]}$的维度需要一致，那如果出现维度不一致的情况怎么办呢？增加一个$W_s$矩阵，<br>$$<br>a^{[l+2]} = g(z^{[l + 2]} + W_s a^{[l]})<br>$$<br>$W_s$有两种方式生成，</p>
<ol>
<li>随机生成的参数矩阵，跟随其他参数一起训练学习。</li>
<li>$a^{[l]}$的基础上采用padding操作生成，比如补0。</li>
</ol>
<h3 id="Networks-in-Networks-and-1x1-Convolutions"><a href="#Networks-in-Networks-and-1x1-Convolutions" class="headerlink" title="Networks in Networks and 1x1 Convolutions"></a>Networks in Networks and 1x1 Convolutions</h3><p>1x1 Convolutons也称为Networks in networks，它是一个1x1的filters并使用了Relu非线性变换。</p>
<h3 id="Inception-Network-Motivation"><a href="#Inception-Network-Motivation" class="headerlink" title="Inception Network Motivation"></a>Inception Network Motivation</h3><p>在构造神经网络的时候，我们有时候会很困惑，用$1\times1$的卷积效果好，还是$f^{[l]}\times f^{[l]}$的卷积效果好，或者用Max-pooling效果会更好呢？Inception Network的思想是，那就把他们在同一层中都用一遍，这样就会得到若干tensor的输出，然后再把这些tensor在channel的纬度上拼在一起，组合一个大的tensor。最后，用数据去训练学习，决定这些filters的参数。</p>
<p>这样会有如下问题，</p>
<ol>
<li>如何让这些tensor在除了channel之外的其他维度上保持尺寸一致？</li>
<li>会不会造成计算量的显著增加？</li>
</ol>
<p>对于问题(1)其实很好解决，采用padding的方式就可以让这些tensor的$n_H$和$n_W$保持一致。</p>
<p>对于问题(2)可以通过在两层网络中间增加一层$1\times1$ filter来解决。下面详细描述原理。</p>
<p>假设我们有这样两层网络，</p>
<p><img src="/img/cnn-w2/inception-2-layer.jpeg" width="50%" title="图 1" align="center"></p>
<p>那么从左到右需要的乘法运算的数量为，<br>$$<br>(28 \times 28 \times 32) \times (5 \times 5 \times 192) \approx 120~million<br>$$<br>如果我们在图(1)两层网络中间加入一层使用了$1\times1$ filter的卷积层，如图(2)所示，</p>
<p><img src="/img/cnn-w2/inception-3-layer.jpeg" width="50%" title="图 2" align="center"></p>
<p>那么从左到右所需要的乘法运算的数量为，<br>$$<br>\begin{split}<br>&amp;1st~layer \rightarrow 2nd~layer：&amp;(28 \times 28 \times 16) \times (1 \times 1 \times 192) \approx 2.4~million \\<br>&amp;2nd~layer \rightarrow 3rd~layer：&amp;(28 \times 28 \times 32) \times (5 \times 5 \times 16) \approx 10~million<br>\end{split}<br>$$<br>也就是共需要$12.4~million$的乘法运算。从中可以看到，加入”bottleneck layer”之后，所需要的计算量减少为了原来的十分之一。</p>
<h3 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h3><p>当我们有一个比较小的训练数据集的时候，我们可以在别人训练好的模型的基础上来达到我们的目的：删除最后的softmax layers，保留之前的layers的模型结构和权重，并在之后增加我们自己的softmax layers。然后用较小的训练数据集来训练我们新增加的layers的参数。这样就可以用较少的数据来得到不错的预测效果。</p>
<p>其中，我们可以预先存储训练数据集中的样本经过之前的layers (删除原先的softmax layers)之后得到的activations，这样就不用在之后训练新的softmax layers参数的时候反复计算，从而节省计算量并提高效率。</p>
<p>随着我们拥有的训练数据的增加，我们可以保留较少层数的参数不发生改变，其余网络层以原先权重为初始参数，然后在新的训练数据集上进行训练调整。如果我们的训练数据足够大，那么原先所有层的参数都可以只作为初始参数，让它们在新的数据集上进行训练调整。</p>
<h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><p>通常在机器学习中，我们需要大量的训练数据，因此有一些常用的有效的增加数据集的方法，</p>
<ul>
<li>Mirroring: 镜像处理</li>
<li>Random Cropping: 随机图像裁剪</li>
<li>Rotation: 图像旋转</li>
<li>Shearing: </li>
<li>Local warping: 局部变形</li>
<li>Color Shifting: 在不同的颜色通道上增减一定的数值，例如$R+20, G-20, B+20$</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Classic-Networks&quot;&gt;&lt;a href=&quot;#Classic-Networks&quot; class=&quot;headerlink&quot; title=&quot;Classic Networks&quot;&gt;&lt;/a&gt;Classic Networks&lt;/h3&gt;&lt;p&gt;LeNet-5的网络结构如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/cnn-w2/lenet-5.jpeg&quot; width=&quot;80%&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="http://houjp.com/tags/cnn/"/>
    
  </entry>
  
  <entry>
    <title>Convolutional Neural Networks / Week 1</title>
    <link href="http://houjp.com/2018/04/01/cnn-w1/"/>
    <id>http://houjp.com/2018/04/01/cnn-w1/</id>
    <published>2018-04-01T15:50:35.000Z</published>
    <updated>2018-04-14T12:37:27.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Computer-Vision"><a href="#Computer-Vision" class="headerlink" title="Computer Vision"></a>Computer Vision</h3><p>Computer Vision Problems include:</p>
<ul>
<li>Image Classication</li>
<li>Object Detection</li>
<li>… …</li>
</ul>
<p>One of the challenges of computer vision problems is that the input can be very big. For example, a 1000 by 1000 image can have $1000 \times  64 \times 3 = 12288$ dimensions because there are three color channels. If the size of hidden layer is 1000, the number of parameters from input layer to hidden layer could be 3 billion. This will cause these problems:</p>
<ol>
<li>data size requirements;</li>
<li>computational requirements;</li>
<li>memory requirements.</li>
</ol>
<a id="more"></a>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>The problems of convolutional operation:</p>
<ol>
<li>shrinking output</li>
<li>throwing away a lot of information from the edges of the image</li>
</ol>
<p>In order to fix these problems, what we need to do is <strong>pad the image</strong>.</p>
<p>通常有两种padding的方式：</p>
<ul>
<li>Valid convolution: 意思是不采用padding的方式。</li>
<li>Same convolution：意思是输出的尺寸和输入的尺寸相同。<ul>
<li>在这种情况下可以推导出$p = \frac{f-1}{2}$，所以在计算机视觉的模型中，filter的尺寸通常是奇数而不是偶数。</li>
<li>Filter的尺寸是奇数还有另外一个好处，就是filter可以有中心像素，可以很方便的用来定位filter的位置。</li>
</ul>
</li>
</ul>
<h3 id="Strided-Convolutions"><a href="#Strided-Convolutions" class="headerlink" title="Strided Convolutions"></a>Strided Convolutions</h3><p>给定如下条件，<br>$$<br>\begin{split}<br>&amp;n\times n~image~~~~&amp;f\times f~filter\\<br>&amp;padding~p&amp;stride~s<br>\end{split}<br>$$<br>经过Strided Convolutions之后得到的tensor的尺寸为，<br>$$<br>\lfloor \frac{n + 2p - f}{s} + 1 \rfloor \times \lfloor \frac{n + 2p - f}{s} + 1 \rfloor<br>$$</p>
<blockquote>
<p>NG在这里提到，我们所谓的convolution并不是真正意义上的卷积，而是应该称为cross-correlation，它之前实际上应该有一个针对卷积核的变换操作，这些操作再加上cross-correlation才是真正的convolution。但是这个变换操作没什么用处，所以通常情况下就省略了。</p>
</blockquote>
<h3 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h3><p>在RGB类型的多通道图像中使用Multiple filters：<br>$$<br>n \times n \times n_c \ast f\times f \times n_c \rightarrow (n - f + 1) \times (n - f + 1) \times {n_c}’<br>$$<br>其中，$n$表示图像的长宽，$f$表示filter的长宽，$n_c$表示图像的通道数，$n_c’$表示filter的个数。</p>
<h3 id="One-Layer-of-a-Convolutional-Network"><a href="#One-Layer-of-a-Convolutional-Network" class="headerlink" title="One Layer of a Convolutional Network"></a>One Layer of a Convolutional Network</h3><p>普通的BP神经网络的数学表达形式如下：<br>$$<br>\begin{split}<br>z^{[1]} &amp;= w^{[1]} a^{[0]} + b^{[1]} \\<br>a^{[1]} &amp;= g(z^{[1]})<br>\end{split}<br>$$<br>在CNN中，convolution operation相当于$w^{[1]}a^{[0]}$，也就是充当了原先线性变换的角色。</p>
<p>这里对卷积层中涉及到的符号进行总结，<br>$$<br>\begin{split}<br>f^{[l]} &amp;= filter~size \\<br>p^{[l]} &amp;= padding \\<br>s^{[l]} &amp;= stride \\<br>n_{C}^{[l]} &amp;= number~of~filters<br>\end{split}<br>\tag{1}<br>$$<br>接着定义卷积层的输入和输出表示，<br>$$<br>\begin{split}<br>Input:~&amp;n_H^{[l-1]} \times n_W^{[l-1]} \times n_C^{[l-1]} \\<br>Output:~&amp;n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]}<br>\end{split}<br>\tag{2}<br>$$</p>
<p>基于(1)和(2)，我们可以进行如下定义，<br>$$<br>\begin{split}<br>&amp;Each~filter~is:~    &amp;f^{[l]} \times f^{[l]} \times n_C^{[l-1]} \\<br>&amp;Activations:~        &amp;a^{[l]} \rightarrow n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]} \\<br>&amp;Weights:~        &amp;f^{[l]} \times f^{[l]} \times n_C^{[l-1]} \times n_C^{[l]} \\<br>&amp;bias:~            &amp;n_C^{[l]}<br>\end{split}<br>\tag{3}<br>$$<br>在式(2)中，$n_H^{[l]}$与$n_H^{[l-1]}$的关系如下，<br>$$<br>n_H^{[l]} = \lfloor \frac{n_H^{[l - 1]} + 2p^{[l]} - f^{[l]}}{s^{l}} + 1 \rfloor<br>$$<br>在式(3)中，Activations是单个样本的形式，batch的形式如下，<br>$$<br>A^{[l]} \rightarrow m \times n_H^{[l]} \times n_W^{[l]} \times n_C^{[l]}<br>$$</p>
<h3 id="Simple-Convolution-Network-Example"><a href="#Simple-Convolution-Network-Example" class="headerlink" title="Simple Convolution Network Example"></a>Simple Convolution Network Example</h3><p>以图像分类为例（识别图片中是否有猫），经过若干卷积层之后，为了得到最终的$0/1$分类结果，会将最后一层卷积的tensor展开并拉长成vector，经过logistic/softmax单元后得到代表预测结果的概率值。</p>
<p>在使用ConvNet的过程中，比较麻烦的地方在于如何确定超参。有一个常用的指导方针是，activations的长和宽需要越来越小（也就是图片的尺寸越来越小），同时通道数需要越来越多（也就是activations的第三个维度）。之后会详细介绍怎么需选择超参。</p>
<p>在ConvNet中，通常有三种类型的网络层，</p>
<ul>
<li>Convolution (CONV)</li>
<li>Pooling (POOL)</li>
<li>Fully connected (FC)</li>
</ul>
<h3 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h3><p>Pooling Layer有如下好处，</p>
<ul>
<li>减少图像representation的尺寸，提高计算速度</li>
<li>提高鲁棒性</li>
</ul>
<p>很有意思的地方在于，对于pooling layer来说，我们只需要确定超参数$f^{[l]}$和$s^{[l]}$，以及是max pooling 还是average pooling，并不需要进行参数的学习。</p>
<p>在pooling layer中，超参$p^{[l]}$通常设置为0。</p>
<h3 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h3><p>神经网络中常用的一种模式是，若干卷积层之后加池化层，再若干层卷积层之后接池化层，然后接全连接层，最后给softmax单元。NG在课上画了一个例子如下，</p>
<div align="center"><br><br><img src="/img/cnn-w1/cnn-example.jpeg" alt="cnn-example"><br><br></div>

<h3 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions"></a>Why Convolutions</h3><p>卷积层最显著的特点就是参数数量大大小于全连接层的数量，因为：</p>
<ol>
<li>Parameter sharing: 图像的不同位置共享filters。</li>
<li>Sparsity of connections: 每个输出值只取决于很小的一部分输入。这样也降低了过拟合的风险。</li>
</ol>
<p>卷积神经网络的损失函数定义如下所示，<br>$$<br>Cost~J = \frac{1}{m} \sum_{i-1}^{m} \mathcal{L}(\hat{y}^{(i)}, y^{(i)})<br>$$</p>
<h3 id="Programming-Assignments"><a href="#Programming-Assignments" class="headerlink" title="Programming Assignments"></a>Programming Assignments</h3><h4 id="Convolutional-Model-step-by-step"><a href="#Convolutional-Model-step-by-step" class="headerlink" title="Convolutional Model: step by step"></a>Convolutional Model: step by step</h4><p>卷积层和池化层的区别：</p>
<ul>
<li>卷积层中的每个filter都会同时作用在不同的channel上</li>
<li>在池化层中，filter与channel一一对应，作用在对应的channel上</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.cnblogs.com/nowgood/p/Latexstart.html" target="_blank" rel="external">MarkDown中使用Latex数学公式</a></li>
<li><a href="http://masikkk.com/article/hexo-13-MathJax/" target="_blank" rel="external">Hexo博客(13)添加MathJax数学公式渲染</a><ul>
<li>解释了Markdown和Mathjax渲染冲突问题</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Computer-Vision&quot;&gt;&lt;a href=&quot;#Computer-Vision&quot; class=&quot;headerlink&quot; title=&quot;Computer Vision&quot;&gt;&lt;/a&gt;Computer Vision&lt;/h3&gt;&lt;p&gt;Computer Vision Problems include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Image Classication&lt;/li&gt;
&lt;li&gt;Object Detection&lt;/li&gt;
&lt;li&gt;… …&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of the challenges of computer vision problems is that the input can be very big. For example, a 1000 by 1000 image can have $1000 \times  64 \times 3 = 12288$ dimensions because there are three color channels. If the size of hidden layer is 1000, the number of parameters from input layer to hidden layer could be 3 billion. This will cause these problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;data size requirements;&lt;/li&gt;
&lt;li&gt;computational requirements;&lt;/li&gt;
&lt;li&gt;memory requirements.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="http://houjp.com/tags/cnn/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Notes</title>
    <link href="http://houjp.com/2018/04/01/hexo-notes/"/>
    <id>http://houjp.com/2018/04/01/hexo-notes/</id>
    <published>2018-04-01T12:56:10.000Z</published>
    <updated>2018-04-14T12:37:27.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更换电脑之后重新部署"><a href="#更换电脑之后重新部署" class="headerlink" title="更换电脑之后重新部署"></a>更换电脑之后重新部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone $&#123;your-repository&#125;</div><div class="line">cd $&#123;your-repository&#125;</div><div class="line">npm install hexo</div><div class="line">npm install</div><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;更换电脑之后重新部署&quot;&gt;&lt;a href=&quot;#更换电脑之后重新部署&quot; class=&quot;headerlink&quot; title=&quot;更换电脑之后重新部署&quot;&gt;&lt;/a&gt;更换电脑之后重新部署&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
    
      <category term="hexo" scheme="http://houjp.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java Nested Classes</title>
    <link href="http://houjp.com/2018/02/12/java-nested-classes/"/>
    <id>http://houjp.com/2018/02/12/java-nested-classes/</id>
    <published>2018-02-12T01:20:29.000Z</published>
    <updated>2018-02-12T11:25:18.446Z</updated>
    
    <content type="html"><![CDATA[<p>Java允许我们在类中定义新的类，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>嵌套在类中的类，被称为<em>Nested Classes</em>。<em>Nested Classes</em>被分为两类：</p>
<ol>
<li>static: 声明为<code>static</code>的nested classes。</li>
<li>non-static: 没有声明为<code>static</code>的nested classes，也被称为inner classes。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Nested class是包含它的类 (enclosing class) 的成员。Non-static nested classes (inner class) 有权限访问enclosing class的包括私有成员在内的其它成员。而static nested class没有权限访问enclosing class的其他成员。</p>
<p>作为OuterClass的成员，nested class可以被声明为private, public, protected或package private (Outer classes只能声明为public或package private)。</p>
<blockquote>
<p><font color="red">TODO</font> 区分protected和package private。 </p>
</blockquote>
<h3 id="Why-Use-Nested-Classes"><a href="#Why-Use-Nested-Classes" class="headerlink" title="Why Use Nested Classes?"></a>Why Use Nested Classes?</h3><p>使用nested classes的原因如下：</p>
<ul>
<li>类只在一个地方被用到，那么这种方式可以将他们组织在一起。</li>
<li>增强了密封性。</li>
<li>增强可读性，并且利于维护。</li>
</ul>
<h3 id="Static-Nested-Classes"><a href="#Static-Nested-Classes" class="headerlink" title="Static Nested Classes"></a>Static Nested Classes</h3><p>与类的方法以及变量类似，static nested classes与它的outer class相关联。一个static nested class不能直接获取定义在enclosing class中的实例的变量或者方法，而是只能通过对象引用，这一点与静态类方法相同。</p>
<p>通过enclosing class的名字来获取static nested classes:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterClass.StaticNestedClass</div></pre></td></tr></table></figure>
<p>创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OuterClass.StaticNestedClass nestedObject =</div><div class="line">     <span class="keyword">new</span> OuterClass.StaticNestedClass();</div></pre></td></tr></table></figure>
<h3 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h3><p>Inner class与它的enclosing class的实例相关联，并且可以访问对象的方法及字段。也正是因为它与实例相关联，所以不能在其中定义任何的静态成员。</p>
<p>Inner class的实例依托于outer class的实例而存在。例如，对于以下的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>InnerClass</code>的实例必须依托于<code>OuterClass</code>的实例而存在，并且可以直接访问其enclosing instance的方法和字段。。</p>
<p>为了实例化inner class，必须先实例化outer class。然后，通过以下方式来创建inner class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OuterClass.InnerClass innerObject = outerObject.new InnerClass();</div></pre></td></tr></table></figure>
<p>有两种特殊的inner classes: </p>
<ul>
<li>local classes</li>
<li>anonymous classes</li>
</ul>
<blockquote>
<p><font color="red">TODO</font> local classes和anonymous classes。</p>
</blockquote>
<h3 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h3><p>如果某个特殊范围(如inner class或者某个方法定义)内的一个类型的声明(如成员变量或者某个参数名)与enclosing scope中的另一个声明有相同的名字，那么enclosing scope中的声明就会被遮盖(shadow)。举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"x = "</span> + x);</div><div class="line">            System.out.println(<span class="string">"this.x = "</span> + <span class="keyword">this</span>.x);</div><div class="line">            System.out.println(<span class="string">"ShadowTest.this.x = "</span> + ShadowTest.<span class="keyword">this</span>.x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">        ShadowTest st = <span class="keyword">new</span> ShadowTest();</div><div class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</div><div class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">23</span></div><div class="line"><span class="keyword">this</span>.x = <span class="number">1</span></div><div class="line">ShadowTest.<span class="keyword">this</span>.x = <span class="number">0</span></div></pre></td></tr></table></figure>
<h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>强烈反对序列化inner classes。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="external">The Java Tutorials: Nested Classes</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java允许我们在类中定义新的类，像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OuterClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NestedClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Guice Custom Scopes</title>
    <link href="http://houjp.com/2018/02/04/guice-custom-scopes/"/>
    <id>http://houjp.com/2018/02/04/guice-custom-scopes/</id>
    <published>2018-02-04T11:08:10.000Z</published>
    <updated>2018-02-04T13:52:44.199Z</updated>
    
    <content type="html"><![CDATA[<p><em>Guice官方并不建议自定义scopes，它认为自带的scopes已经足够使用。</em></p>
<p>创建custom scopes需要以下几步：</p>
<ol>
<li>定义一个scoping annotation。</li>
<li>实现<code>Scope</code>接口。</li>
<li>将scope annotation绑定到它的实现。</li>
<li>触发scope的开始以及结束。</li>
</ol>
<a id="more"></a>
<h3 id="Defining-a-scoping-annotation"><a href="#Defining-a-scoping-annotation" class="headerlink" title="Defining a scoping annotation"></a>Defining a scoping annotation</h3><p>Scoping annotation用来标识自定义的scope，可以用它来注解Guice构造生成的类型、<code>@Provides</code>方法以及用在<code>in()</code>从句用于声明绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Target;</div><div class="line"></div><div class="line"><span class="meta">@Target</span>(&#123; TYPE, METHOD &#125;) <span class="meta">@Retention</span>(RUNTIME) <span class="meta">@ScopeAnnotation</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BatchScoped &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="Implement-Scope"><a href="#Implement-Scope" class="headerlink" title="Implement Scope"></a>Implement Scope</h3><p>Scope接口可以保证在每个scope实例中每种类型最多只有一个实例。官方提供了一个实现叫做<code>SimpleScope</code>，我们可以直接使用，也可以根据需要对<code>SimpleScope</code>进行调整生成自己的Scope实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.google.common.base.Preconditions.checkState;</div><div class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</div><div class="line"><span class="keyword">import</span> com.google.inject.Key;</div><div class="line"><span class="keyword">import</span> com.google.inject.OutOfScopeException;</div><div class="line"><span class="keyword">import</span> com.google.inject.Provider;</div><div class="line"><span class="keyword">import</span> com.google.inject.Scope;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Scopes a single execution of a block of code. Apply this scope with a</span></div><div class="line"><span class="comment"> * try/finally block: &lt;pre&gt;&lt;code&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   scope.enter();</span></div><div class="line"><span class="comment"> *   try &#123;</span></div><div class="line"><span class="comment"> *     // explicitly seed some seed objects...</span></div><div class="line"><span class="comment"> *     scope.seed(Key.get(SomeObject.class), someObject);</span></div><div class="line"><span class="comment"> *     // create and access scoped objects</span></div><div class="line"><span class="comment"> *   &#125; finally &#123;</span></div><div class="line"><span class="comment"> *     scope.exit();</span></div><div class="line"><span class="comment"> *   &#125;</span></div><div class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The scope can be initialized with one or more seed values by calling</span></div><div class="line"><span class="comment"> * &lt;code&gt;seed(key, value)&lt;/code&gt; before the injector will be called upon to</span></div><div class="line"><span class="comment"> * provide for this key. A typical use is for a servlet filter to enter/exit the</span></div><div class="line"><span class="comment"> * scope, representing a Request Scope, and seed HttpServletRequest and</span></div><div class="line"><span class="comment"> * HttpServletResponse.  For each key inserted with seed(), you must include a</span></div><div class="line"><span class="comment"> * corresponding binding:</span></div><div class="line"><span class="comment"> *  &lt;pre&gt;&lt;code&gt;</span></div><div class="line"><span class="comment"> *   bind(key)</span></div><div class="line"><span class="comment"> *       .toProvider(SimpleScope.&amp;lt;KeyClass&amp;gt;seededKeyProvider())</span></div><div class="line"><span class="comment"> *       .in(ScopeAnnotation.class);</span></div><div class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Jesse Wilson</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> Fedor Karpelevitch</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Provider&lt;Object&gt; SEEDED_KEY_PROVIDER =</div><div class="line">      <span class="keyword">new</span> Provider&lt;Object&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"If you got here then it means that"</span> +</div><div class="line">              <span class="string">" your code asked for scoped object which should have been"</span> +</div><div class="line">              <span class="string">" explicitly seeded in this scope by calling"</span> +</div><div class="line">              <span class="string">" SimpleScope.seed(), but was not."</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Key&lt;?&gt;, Object&gt;&gt; values</div><div class="line">      = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;Key&lt;?&gt;, Object&gt;&gt;();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</div><div class="line">    checkState(values.get() == <span class="keyword">null</span>, <span class="string">"A scoping block is already in progress"</span>);</div><div class="line">    values.set(Maps.&lt;Key&lt;?&gt;, Object&gt;newHashMap());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</div><div class="line">    checkState(values.get() != <span class="keyword">null</span>, <span class="string">"No scoping block in progress"</span>);</div><div class="line">    values.remove();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">seed</span><span class="params">(Key&lt;T&gt; key, T value)</span> </span>&#123;</div><div class="line">    Map&lt;Key&lt;?&gt;, Object&gt; scopedObjects = getScopedObjectMap(key);</div><div class="line">    checkState(!scopedObjects.containsKey(key), <span class="string">"A value for the key %s was "</span> +</div><div class="line">        <span class="string">"already seeded in this scope. Old value: %s New value: %s"</span>, key,</div><div class="line">        scopedObjects.get(key), value);</div><div class="line">    scopedObjects.put(key, value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">seed</span><span class="params">(Class&lt;T&gt; clazz, T value)</span> </span>&#123;</div><div class="line">    seed(Key.get(clazz), value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Provider&lt;T&gt; <span class="title">scope</span><span class="params">(<span class="keyword">final</span> Key&lt;T&gt; key, <span class="keyword">final</span> Provider&lt;T&gt; unscoped)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Provider&lt;T&gt;() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Map&lt;Key&lt;?&gt;, Object&gt; scopedObjects = getScopedObjectMap(key);</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        T current = (T) scopedObjects.get(key);</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span> &amp;&amp; !scopedObjects.containsKey(key)) &#123;</div><div class="line">          current = unscoped.get();</div><div class="line"></div><div class="line">          <span class="comment">// don't remember proxies; these exist only to serve circular dependencies</span></div><div class="line">          <span class="keyword">if</span> (Scopes.isCircularProxy(current)) &#123;</div><div class="line">            <span class="keyword">return</span> current;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          scopedObjects.put(key, current);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> current;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> &lt;T&gt; Map&lt;Key&lt;?&gt;, Object&gt; getScopedObjectMap(Key&lt;T&gt; key) &#123;</div><div class="line">    Map&lt;Key&lt;?&gt;, Object&gt; scopedObjects = values.get();</div><div class="line">    <span class="keyword">if</span> (scopedObjects == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> OutOfScopeException(<span class="string">"Cannot access "</span> + key</div><div class="line">          + <span class="string">" outside of a scoping block"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> scopedObjects;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Returns a provider that always throws exception complaining that the object</span></div><div class="line"><span class="comment">   * in question must be seeded before it can be injected.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> typed provider</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Provider&lt;T&gt; <span class="title">seededKeyProvider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Provider&lt;T&gt;) SEEDED_KEY_PROVIDER;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Binding-the-annotation-to-the-implementation"><a href="#Binding-the-annotation-to-the-implementation" class="headerlink" title="Binding the annotation to the implementation"></a>Binding the annotation to the implementation</h3><p>我们必须将scoping annotation绑定到对应的scope implementation上，这个在module的<code>configure()</code>方法中配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchScopeModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    SimpleScope batchScope = <span class="keyword">new</span> SimpleScope();</div><div class="line"></div><div class="line">    <span class="comment">// tell Guice about the scope</span></div><div class="line">    bindScope(BatchScoped.class, batchScope);</div><div class="line"></div><div class="line">    <span class="comment">// make our scope instance injectable</span></div><div class="line">    bind(SimpleScope.class)</div><div class="line">        .annotatedWith(Names.named(<span class="string">"batchScope"</span>))</div><div class="line">        .toInstance(batchScope);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Triggering-the-Scope"><a href="#Triggering-the-Scope" class="headerlink" title="Triggering the Scope"></a>Triggering the Scope</h3><p><code>SimpleScope</code>需要手动进入和退出。需要注意：调用<code>exit()</code>方法需要在<code>finally</code>从句中，否则如果抛出了异常，scope将一直处于open状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"batchScope"</span>) SimpleScope scope;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Runs &#123;<span class="doctag">@code</span> runnable&#125; in batch scope.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scopeRunnable</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">  scope.enter();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// explicitly seed some seed objects...</span></div><div class="line">    scope.seed(Key.get(SomeObject.class), someObject);</div><div class="line"></div><div class="line">    <span class="comment">// create and access scoped objects</span></div><div class="line">    runnable.run();</div><div class="line"></div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    scope.exit();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Guice官方并不建议自定义scopes，它认为自带的scopes已经足够使用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;创建custom scopes需要以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个scoping annotation。&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Scope&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;将scope annotation绑定到它的实现。&lt;/li&gt;
&lt;li&gt;触发scope的开始以及结束。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="guice" scheme="http://houjp.com/tags/guice/"/>
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency之Thread Synchronization</title>
    <link href="http://houjp.com/2018/01/28/java-concurrency-thread-synchronization/"/>
    <id>http://houjp.com/2018/01/28/java-concurrency-thread-synchronization/</id>
    <published>2018-01-28T15:15:16.000Z</published>
    <updated>2018-01-28T17:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Concurrency-Issues"><a href="#Concurrency-Issues" class="headerlink" title="Concurrency Issues"></a>Concurrency Issues</h3><p>当多个线程并发读写共享数据的时候，会造成如下问题：</p>
<ol>
<li>Thread interference errors</li>
<li>Memory consistency errors</li>
</ol>
<a id="more"></a>
<h3 id="Thread-Interference-Errors-Race-Conditions"><a href="#Thread-Interference-Errors-Race-Conditions" class="headerlink" title="Thread Interference Errors (Race Conditions)"></a>Thread Interference Errors (Race Conditions)</h3><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        count = count + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaceConditionExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">        Counter counter = <span class="keyword">new</span> Counter();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            executorService.submit(() -&gt; counter.increment());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">        executorService.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line">    </div><div class="line">        System.out.println(<span class="string">"Final count is : "</span> + counter.getCount());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果不是1000，而是 992或996或993或…</p>
<p>因为当我们执行increment()方法时，发生了如下操作：</p>
<ol>
<li>检索当前count的当前值</li>
<li>检索到的值加1</li>
<li>将增加后的值存储到count</li>
</ol>
<p>不同线程的这些步骤发生了交叉造成了不可预期的结果。</p>
<blockquote>
<p>When multiple threads try to read and write a shared variable concurrently, and these read and write operations overlap in execution, then the final outcome depends on the order in which the reads and writes take place, which is unpredictable. This phenomenon is called <a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="external">Race condition</a>.</p>
<p>The section of the code where a shared variable is accessed is called <a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="external">Critical Section</a>.</p>
</blockquote>
<p>这个错误可以通过对shared variables的synchronizing access来避免。</p>
<h3 id="Memory-Consistency-Errors"><a href="#Memory-Consistency-Errors" class="headerlink" title="Memory Consistency Errors"></a>Memory Consistency Errors</h3><blockquote>
<p>Memory inconsistency errors occur when different threads have inconsistent views of the same data. This happens when one thread updates some shared data, but this update is not propagated to other threads, and they end up using the old data.</p>
</blockquote>
<p>为什么会发生这种现象：</p>
<ol>
<li>Compiler可能对你的程序进行了优化来提升性能。</li>
<li>Processors可能尝试进行了优化，比如一个processor可能从temporary register读取变量（含有变量最近一次读取的值），而不是main memory（含有变量最新的值）。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryConsistencyErrorExample</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sayHello = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">           <span class="keyword">while</span>(!sayHello) &#123;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line"></div><div class="line">           <span class="keyword">while</span>(sayHello) &#123;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           System.out.println(<span class="string">"Good Bye!"</span>);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"Say Hello.."</span>);</div><div class="line">        sayHello = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"Say Bye.."</span>);</div><div class="line">        sayHello = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>期望的输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Ideal Output</div><div class="line">Say Hello..</div><div class="line">Hello World!</div><div class="line">Say Bye..</div><div class="line">Good Bye!</div></pre></td></tr></table></figure>
<p>实际输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Actual Output</div><div class="line">Say Hello..</div><div class="line">Say Bye..</div></pre></td></tr></table></figure>
<p>程序甚至没有终止。为什么呢？</p>
<p>第一个线程没有意识到主线程改变了<code>sayHello</code>变量的值。</p>
<p>我们可以用<code>volatile</code>关键字来避免这个问题。</p>
<h3 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h3><p>Thread interference和memory consistency errors可以在满足以下两个条件的情况下被避免：</p>
<ol>
<li>一次只有一个线程可以读写共享变量。</li>
<li>如果有线程修改了共享变量，它自动与其他随后读写该共享变量的线程建立了happens-before的关系。这保证了完成的修改操作可以被其他线程看到。</li>
</ol>
<p>Java有<code>synchronized</code>关键字来synchronize access共享变量来避免这些问题。</p>
<h4 id="Synchronized-Methods"><a href="#Synchronized-Methods" class="headerlink" title="Synchronized Methods"></a>Synchronized Methods</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Synchronized Method </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        count = count + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethodExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">        SynchronizedCounter synchronizedCounter = <span class="keyword">new</span> SynchronizedCounter();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            executorService.submit(() -&gt; synchronizedCounter.increment());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">        executorService.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Final count is : "</span> + synchronizedCounter.getCount());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronization的概念通常都会与一个对象绑定。在上述例子中，同一个对象的<code>increment()</code>方法不能被同时多次调用，但是不同对象的<code>increment()</code>方法可以被不同的线程同时调用。</p>
<p>在静态方法中，synchronization与Class对象绑定。</p>
<h4 id="Synchronized-Blocks"><a href="#Synchronized-Blocks" class="headerlink" title="Synchronized Blocks"></a>Synchronized Blocks</h4><p>Java使用<em>intrinsic lock</em>或者<em>monitor lock</em>来管理线程的同步。每个对象都有一个与之关联的<em>intrinsic lock</em>。</p>
<p>当线程调用对象的synchronized method时，会自动获取该对象的intrinsic lock，在方法调用结束后释放它。如果方法抛出了异常，也会释放该锁。</p>
<p>对于静态方法，线程会请求与类有关的<code>Class</code>对象的intrinsic lock，它与类任意实例的intrinsic lock不同。</p>
<p><code>synchronized</code>关键字也可以作为block statement，与<code>synchronized method</code>不同，<code>synchronized statements</code>必须指明提供intrinsic lock的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Synchronized Block - </span></div><div class="line"></div><div class="line">    <span class="comment">// Acquire Lock</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </div><div class="line">        count = count + <span class="number">1</span>;</div><div class="line">    &#125;   </div><div class="line">    <span class="comment">// Release Lock</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个线程获取了一个对象的intrinsic lock，那么其他进程必须等待锁被释放。然而，拥有该锁的进程可以多次获取该锁而不会有任何问题。</p>
<blockquote>
<p>The idea of allowing a thread to acquire the same lock more than once is called <em>Reentrant Synchronization</em>.</p>
</blockquote>
<h3 id="Volatile-Keyword"><a href="#Volatile-Keyword" class="headerlink" title="Volatile Keyword"></a>Volatile Keyword</h3><p>Volatile keyword用来避免多线程程序中的memory consistency errors。它告诉compiler不要对变量做优化，compiler不会优化或者重排序该变量的指令。</p>
<p>而且，变量的值会从main memory来读取，而不是临时寄存器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileKeywordExample</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> sayHello = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">           <span class="keyword">while</span>(!sayHello) &#123;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line"></div><div class="line">           <span class="keyword">while</span>(sayHello) &#123;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           System.out.println(<span class="string">"Good Bye!"</span>);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"Say Hello.."</span>);</div><div class="line">        sayHello = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"Say Bye.."</span>);</div><div class="line">        sayHello = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样会得到想要的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Say Hello..</div><div class="line">Hello World!</div><div class="line">Say Bye..</div><div class="line">Good Bye!</div></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.callicoder.com/java-concurrency-issues-and-thread-synchronization/" target="_blank" rel="external">Java Concurrency issues and Synchronization</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Concurrency-Issues&quot;&gt;&lt;a href=&quot;#Concurrency-Issues&quot; class=&quot;headerlink&quot; title=&quot;Concurrency Issues&quot;&gt;&lt;/a&gt;Concurrency Issues&lt;/h3&gt;&lt;p&gt;当多个线程并发读写共享数据的时候，会造成如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Thread interference errors&lt;/li&gt;
&lt;li&gt;Memory consistency errors&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="concurrency" scheme="http://houjp.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency之Callable and Future</title>
    <link href="http://houjp.com/2018/01/28/java-concurrency-callable-and-future/"/>
    <id>http://houjp.com/2018/01/28/java-concurrency-callable-and-future/</id>
    <published>2018-01-28T14:34:49.000Z</published>
    <updated>2018-01-28T15:15:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p><code>Runnable</code>虽然方便但是不能让tasks的执行拥有返回值。</p>
<p>Java还提供了<code>Callable</code>接口来让tasks返回结果。<code>Callable</code>和<code>Runnable</code>类似，除了可以返回结果以及会抛出一个checked exeption。</p>
<a id="more"></a>
<p><code>Callable</code>接口拥有单个方法<code>call()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// Perform some computation</span></div><div class="line">        Thread.sleep(<span class="number">2000</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"Return some result"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Callable</code>不需要在<code>Thread.sleep()</code>外使用try/catch代码块，因为Callable可以抛出checked exception</p>
<blockquote>
<p><font color="red">TODO</font>Java中checked exception指什么？</p>
</blockquote>
<p>使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Callable&lt;String&gt; callable = () -&gt; &#123;</div><div class="line">    <span class="comment">// Perform some computation</span></div><div class="line">    Thread.sleep(<span class="number">2000</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">"Return some result"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Executing-Callable-tasks-using-ExecutorService-and-obtaining-the-result-using-Future"><a href="#Executing-Callable-tasks-using-ExecutorService-and-obtaining-the-result-using-Future" class="headerlink" title="Executing Callable tasks using ExecutorService and obtaining the result using Future"></a>Executing Callable tasks using ExecutorService and obtaining the result using Future</h3><p>Executor service<code>submit()</code>方法可以提交task给线程执行，但是并不知道什么时候结果可以被获取。因此，它返回来一种特殊的类型<code>Future</code>。这个类型可以用于在结果准备好之后获取结果。</p>
<p><code>Future</code>的概念和其他语言如JavaScript中的<code>Promise</code>相似。</p>
<blockquote>
<p><code>Future</code> represents the result of a computation that will be completed at a later point of time in future.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAndCallableExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</div><div class="line">            <span class="comment">// Perform some computation</span></div><div class="line">            System.out.println(<span class="string">"Entered Callable"</span>);</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Hello from Callable"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Submitting Callable"</span>);</div><div class="line">        Future&lt;String&gt; future = executorService.submit(callable);</div><div class="line"></div><div class="line">        <span class="comment">// This line executes immediately</span></div><div class="line">        System.out.println(<span class="string">"Do something else while callable is getting executed"</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Retrieve the result of the future"</span>);</div><div class="line">        <span class="comment">// Future.get() blocks until the result is available</span></div><div class="line">        String result = future.get();</div><div class="line">        System.out.println(result);</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Submitting Callable</div><div class="line">Do something else while callable is getting executed</div><div class="line">Retrieve the result of the future</div><div class="line">Entered Callable</div><div class="line">Hello from Callable</div></pre></td></tr></table></figure>
<p><code>ExecutorService.submit()</code>会直接返回<code>Future</code>。一旦拿到它，就可以并行执行其他tasks，这时候之前提交的task还在执行。之后可以用<code>future.get()</code>来获取结果。</p>
<p><code>get()</code>方法会阻塞，直到任务完成。<code>Future</code> API也提供了一个<code>isDone()</code>方法来判断task是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureIsDoneExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line">        Future&lt;String&gt; future = executorService.submit(() -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Hello from Callable"</span>;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!future.isDone()) &#123;</div><div class="line">            System.out.println(<span class="string">"Task is still not done..."</span>);</div><div class="line">            Thread.sleep(<span class="number">200</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Task completed! Retrieving the result"</span>);</div><div class="line">        String result = future.get();</div><div class="line">        System.out.println(result);</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task completed! Retrieving the result</div><div class="line">Hello from Callable</div></pre></td></tr></table></figure>
<h3 id="Cancelling-a-Future"><a href="#Cancelling-a-Future" class="headerlink" title="Cancelling a Future"></a>Cancelling a Future</h3><p><code>Future.cancel()</code>可以取消future。返回一个boolean表示是否取消成功。</p>
<p><code>cancel()</code>方法接收<code>mayInterruptIfRunning</code>参数。<code>true</code>表示如果这个task正在执行就会被中断执行，<code>false</code>表示如果正在执行会等待执行完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCancelExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</div><div class="line">        Future&lt;String&gt; future = executorService.submit(() -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Hello from Callable"</span>;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!future.isDone()) &#123;</div><div class="line">            System.out.println(<span class="string">"Task is still not done..."</span>);</div><div class="line">            Thread.sleep(<span class="number">200</span>);</div><div class="line">            <span class="keyword">double</span> elapsedTimeInSec = (System.nanoTime() - startTime)/<span class="number">1000000000.0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(elapsedTimeInSec &gt; <span class="number">1</span>) &#123;</div><div class="line">                future.cancel(<span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Task completed! Retrieving the result"</span>);</div><div class="line">        String result = future.get();</div><div class="line">        System.out.println(result);</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task is still not done...</div><div class="line">Task completed! Retrieving the result</div><div class="line">Exception in thread "main" java.util.concurrent.CancellationException</div><div class="line">        at java.util.concurrent.FutureTask.report(FutureTask.java:121)</div><div class="line">        at java.util.concurrent.FutureTask.get(FutureTask.java:192)</div><div class="line">        at FutureCancelExample.main(FutureCancelExample.java:34)</div></pre></td></tr></table></figure>
<p>Task被取消后，<code>future.get()</code>会抛出<code>CancellationException</code>异常。改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!future.isCancelled()) &#123;</div><div class="line">    System.out.println(<span class="string">"Task completed! Retrieving the result"</span>);</div><div class="line">    String result = future.get();</div><div class="line">    System.out.println(result);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.println(<span class="string">"Task was cancelled"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Adding-Timeouts"><a href="#Adding-Timeouts" class="headerlink" title="Adding Timeouts"></a>Adding Timeouts</h3><p><code>future.get()</code>会阻塞线程并等待task完成，如果不设置超时选项，<code>future.get()</code>在任务无法完成的情况下会被永远阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">future.get(<span class="number">1</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure>
<p>如果无法再规定时间内完成，会抛出<code>TimeoutException</code>。</p>
<h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p>提交多个tasks，并且等待他们全部完成。</p>
<p>可以提交Callables的集合给<code>invokeAll()</code>方法，它会返回Futures的列表。任何一个<code>future.get()</code>的调用都会被阻塞，除非全部完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeAllExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task1 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task1"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task2 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task2"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task3 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task3"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        List&lt;Callable&lt;String&gt;&gt; taskList = Arrays.asList(task1, task2, task3);</div><div class="line"></div><div class="line">        List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(taskList);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(Future&lt;String&gt; future: futures) &#123;</div><div class="line">            <span class="comment">// The result is printed only after all the futures are complete. (i.e. after 5 seconds)</span></div><div class="line">            System.out.println(future.get());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Result of Task1</div><div class="line">Result of Task2</div><div class="line">Result of Task3</div></pre></td></tr></table></figure>
<h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>批量提交，等待任一完成。</p>
<p><code>invokeAny()</code>方法会接受<code>Callables</code>集合，返回执行最快的Callable的结果。它不会返回Future。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeAnyExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task1 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task1"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task2 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task2"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Callable&lt;String&gt; task3 = () -&gt; &#123;</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"Result of Task3"</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Returns the result of the fastest callable. (task2 in this case)</span></div><div class="line">        String result = executorService.invokeAny(Arrays.asList(task1, task2, task3));</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Result of Task2</div></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.callicoder.com/java-callable-and-future-tutorial/" target="_blank" rel="external">Java Callable and Future Tutorial</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Runnable&lt;/code&gt;虽然方便但是不能让tasks的执行拥有返回值。&lt;/p&gt;
&lt;p&gt;Java还提供了&lt;code&gt;Callable&lt;/code&gt;接口来让tasks返回结果。&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;Runnable&lt;/code&gt;类似，除了可以返回结果以及会抛出一个checked exeption。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="concurrency" scheme="http://houjp.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency之Executor Service &amp; Thread Pool</title>
    <link href="http://houjp.com/2018/01/28/java-concurrency-executor-service-thread-pool/"/>
    <id>http://houjp.com/2018/01/28/java-concurrency-executor-service-thread-pool/</id>
    <published>2018-01-28T11:01:57.000Z</published>
    <updated>2018-01-28T17:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Executor-Framework"><a href="#Executor-Framework" class="headerlink" title="Executor Framework"></a>Executor Framework</h3><p>大型的多线程应用可能有成百上千个应用，因此需要将线程的创建和应用其他部分的管理进行区分。</p>
<p><strong>Executors, 是一个帮助你创建和管理线程的框架</strong>：</p>
<ol>
<li>线程创建：提供了创建线程的多种方法，具体的说就是一个线程池，应用可以用它来并发的执行tasks。</li>
<li>线程管理：它管理线程池中线程的生命周期。你不需要关心线程池中的线程是否active/busy/dead/…。</li>
<li>任务创建和执行：Executors框架提供了方法来提交tasks到线程池运行，并且我们可以决定tasks什么时候被执行。</li>
</ol>
<a id="more"></a>
<p>Java Concurrency API定义了如下三种executor interfaces:</p>
<ul>
<li><strong>Executor</strong> 一个简单的接口，包含一个<code>execute()</code>方法用来启动<code>Runnable</code>对象指定的task。</li>
<li><strong>ExecutorService</strong> 是<code>Executor</code>的子接口，添加了管理tasks生命周期的方法。它提供了<code>submit()</code>方法，该方法的重载版本可以接受<code>Runnable</code>和<code>Callable</code>对象。Callable对象和Runnable类似，区别在于Callable对象指定的task可以返回一个值。</li>
<li><strong>ScheduledExecutorService</strong> <code>ExecutorService</code>的子接口。添加了方法类调度tasks的执行。</li>
</ul>
<p>除了上述三种接口，API还提供了<code>Executors</code>类，其中包含了用来创建不同类型executor services的工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Executor Service..."</span>);</div><div class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating a Runnable..."</span>);</div><div class="line">        Runnable runnable = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Submit the task specified by the runnable to the executor service."</span>);</div><div class="line">        executorService.submit(runnable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Inside : main</div><div class="line">Creating Executor Service...</div><div class="line">Creating a Runnable...</div><div class="line">Submit the task specified by the runnable to the executor service.</div><div class="line">Shutting down the executor</div><div class="line">Inside : pool-1-thread-1</div></pre></td></tr></table></figure>
<p>如果task被提交时，thread目前正在执行另一个task，那么新的task就会进入等待队列直到线程空闲。</p>
<p>上述程序不会自动退出，因为executor service会一直监听是否有新的task被提交，除非我们显示关闭它。</p>
<p>ExecutorService提供了两种方法关闭executor:</p>
<ul>
<li><strong>shutdown()</strong> 停止接收新的task，等待之前的tasks执行完毕，然后关闭executor。</li>
<li><strong>shutdownNow()</strong> 终止正在执行的task，立即关闭executor。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Shutting down the executor"</span>);</div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure>
<p>创建线程池，并发执行tasks:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Executor Service with a thread pool of Size 2"</span>);</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line"></div><div class="line">        Runnable task1 = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Executing Task1 inside : "</span> + Thread.currentThread().getName());</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Runnable task2 = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Executing Task2 inside : "</span> + Thread.currentThread().getName());</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Runnable task3 = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Executing Task3 inside : "</span> + Thread.currentThread().getName());</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Submitting the tasks for execution..."</span>);</div><div class="line">        executorService.submit(task1);</div><div class="line">        executorService.submit(task2);</div><div class="line">        executorService.submit(task3);</div><div class="line"></div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Output</div><div class="line">Inside : main</div><div class="line">Creating Executor Service with a thread pool of Size <span class="number">2</span></div><div class="line">Submitting the tasks <span class="keyword">for</span> execution...</div><div class="line">Executing Task1 inside : pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">Shutting down the ExecutorService...</div><div class="line">Executing Task2 inside : pool-<span class="number">1</span>-thread-<span class="number">2</span></div><div class="line">Executing Task3 inside : pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">Completed Task3 inside : pool-<span class="number">1</span>-thread-<span class="number">1</span></div></pre></td></tr></table></figure>
<p>Fixed thread pool在多线程编程中很常见。在fixed thread pool中，executor service会保证池中有指定数量的线程。运行。如果一个线程挂了，会立即被新的线程替代。</p>
<p>如果提交的tasks数量超过的可用的线程数量，那么新的tasks会在队列中等待直到轮到它们执行。</p>
<h3 id="Thread-Pool"><a href="#Thread-Pool" class="headerlink" title="Thread Pool"></a>Thread Pool</h3><p>大多数executor的实现采用的是<em>thread pools</em>来执行tasks。在一个线程池中有多个worker threads，这些与<code>Runnable</code>/<code>Callable</code> tasks不同并且被executor所管理。</p>
<p>创建线程时代价很大的操作，因此应该被避免。Worker threads的存在减少了创建线程的开销，因为executor service只会创建一次线程池，并通过复用线程来执行tasks。</p>
<p>Tasks会通过中间队列<strong>Blocking Queue</strong>被提交到线程池。如果tasks数量大于active threads数量，就被会塞入blocking queue来等待有线程被释放。如果blocking queue满了，新的tasks会被拒绝。</p>
<div align="center"><br><br><img src="/img/java-concurrency-executor-service-thread-pool/executor-service-thread-pool-blocking-queue-example.jpg" alt="executor-service-thread-pool-blocking-queue-example"><br><br></div>

<h3 id="Schedule-Executors"><a href="#Schedule-Executors" class="headerlink" title="Schedule Executors"></a>Schedule Executors</h3><p>ScheduleExecutorService可以周期性的执行tasks或指定delay的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorsExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line">        Runnable task = () -&gt; &#123;</div><div class="line">          System.out.println(<span class="string">"Executing Task At "</span> + System.nanoTime());</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Submitting task at "</span> + System.nanoTime() + <span class="string">" to be executed after 5 seconds."</span>);</div><div class="line">        scheduledExecutorService.schedule(task, <span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">        </div><div class="line">        scheduledExecutorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>周期执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorsPeriodicExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line"></div><div class="line">        Runnable task = () -&gt; &#123;</div><div class="line">          System.out.println(<span class="string">"Executing Task At "</span> + System.nanoTime());</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"scheduling task to be executed every 2 seconds with an initial delay of 0 seconds"</span>);</div><div class="line">        scheduledExecutorService.scheduleAtFixedRate(task, <span class="number">0</span>,<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.callicoder.com/java-executor-service-and-thread-pool-tutorial/" target="_blank" rel="external">Java ExecutorService and Thread Pools Tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Executor-Framework&quot;&gt;&lt;a href=&quot;#Executor-Framework&quot; class=&quot;headerlink&quot; title=&quot;Executor Framework&quot;&gt;&lt;/a&gt;Executor Framework&lt;/h3&gt;&lt;p&gt;大型的多线程应用可能有成百上千个应用，因此需要将线程的创建和应用其他部分的管理进行区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Executors, 是一个帮助你创建和管理线程的框架&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程创建：提供了创建线程的多种方法，具体的说就是一个线程池，应用可以用它来并发的执行tasks。&lt;/li&gt;
&lt;li&gt;线程管理：它管理线程池中线程的生命周期。你不需要关心线程池中的线程是否active/busy/dead/…。&lt;/li&gt;
&lt;li&gt;任务创建和执行：Executors框架提供了方法来提交tasks到线程池运行，并且我们可以决定tasks什么时候被执行。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="concurrency" scheme="http://houjp.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency之Thread and Runnable</title>
    <link href="http://houjp.com/2018/01/28/java-concurrency-thread-and-runnable/"/>
    <id>http://houjp.com/2018/01/28/java-concurrency-thread-and-runnable/</id>
    <published>2018-01-28T09:39:42.000Z</published>
    <updated>2018-01-28T10:56:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Creating-and-Strating-a-Thread"><a href="#Creating-and-Strating-a-Thread" class="headerlink" title="Creating and Strating a Thread"></a>Creating and Strating a Thread</h3><p>Java有两种方式创建线程。</p>
<h4 id="1-By-extending-Thread-class"><a href="#1-By-extending-Thread-class" class="headerlink" title="1. By extending Thread class"></a>1. By extending Thread class</h4><p>继承<code>Thread</code>类，重载<code>run()</code>方法。<code>run()</code>方法中是该线程的执行逻辑。当创建好之后，通过<code>start()</code>方法来启动它。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// run() method contains the code that is executed by the thread.</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating thread..."</span>);</div><div class="line">        Thread thread = <span class="keyword">new</span> ThreadExample();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Starting thread..."</span>);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Inside : main</div><div class="line">Creating thread...</div><div class="line">Starting thread...</div><div class="line">Inside : Thread-0</div></pre></td></tr></table></figure>
<p>可以通过<code>Thread(String name)</code>构造方法来自定义线程名字。</p>
<h4 id="2-By-providing-a-Runnable-object"><a href="#2-By-providing-a-Runnable-object" class="headerlink" title="2. By providing a Runnable object"></a>2. By providing a Runnable object</h4><p><code>Runnable</code>接口是一个重要的模板，用来在线程中执行某个对象。它定义了单个方法<code>run()</code>，其中包含的是意图在线程中执行的代码。</p>
<p>任何一个类，如果它的实例想要单独的线程中执行，那么它需要实现<code>Runnable</code>接口。</p>
<p><strong><code>Thread</code>类也实现了<code>Runnable</code>，不过它的<code>run()</code>方法是空的。</strong></p>
<p>如果想要创建一个新的进程，需要：</p>
<ol>
<li>该类实现<code>Runnable</code>接口。</li>
<li>为该类创建一个实例。</li>
<li>将该实例传给<code>Thread(Runnable target)</code>构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Runnable..."</span>);</div><div class="line">        Runnable runnable = <span class="keyword">new</span> RunnableExample();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Thread..."</span>);</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Starting Thread..."</span>);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Inside : main</div><div class="line">Creating Runnable...</div><div class="line">Creating Thread...</div><div class="line">Starting Thread...</div><div class="line">Inside : Thread-0</div></pre></td></tr></table></figure>
<p>以上的这种写法需要创建一个实现了<code>Runnable</code>的类，再将其实例化，我们可以利用Java的<em>anonymous class</em>语法创建一个anonymous runnable。</p>
<blockquote>
<p><font color="red">TODO</font> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html" target="_blank" rel="external">anonymous class</a></p>
<p><em>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time.</em> - From Java doc.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableExampleAnonymousClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Runnable..."</span>);</div><div class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Thread..."</span>);</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Starting Thread..."</span>);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再加上Java 8的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableExampleLambdaExpression</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Runnable..."</span>);</div><div class="line">        Runnable runnable = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Creating Thread..."</span>);</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Starting Thread..."</span>);</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Runnable-or-Thread-Which-one-to-use"><a href="#Runnable-or-Thread-Which-one-to-use" class="headerlink" title="Runnable or Thread, Which one to use?"></a>Runnable or Thread, Which one to use?</h3><p>通过扩展<code>Thread</code>类的方法是存在局限性的。一旦通过<code>Thread</code>将类进行扩展，我们就不能再从其他类中扩展，因为Java不允许<em>multiple inheritance</em>。</p>
<p>从design practice角度来看，<em>inheritance</em>意味着你想要扩展父类的方法，但是当创建一个线程时，通常只是实现了<code>run()</code>方法而没有进行扩展。</p>
<p>所以一般来说，要用<code>Runnable</code>来创建线程。</p>
<h3 id="Pausing-execution-of-a-Thread-using-sleep"><a href="#Pausing-execution-of-a-Thread-using-sleep" class="headerlink" title="Pausing execution of a Thread using sleep()"></a>Pausing execution of a Thread using sleep()</h3><p><code>sleep()</code>方法可以暂停线程的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">        String[] messages = &#123;<span class="string">"If I can stop one heart from breaking,"</span>,</div><div class="line">                <span class="string">"I shall not live in vain."</span>,</div><div class="line">                <span class="string">"If I can ease one life the aching,"</span>,</div><div class="line">                <span class="string">"Or cool one pain,"</span>,</div><div class="line">                <span class="string">"Or help one fainting robin"</span>,</div><div class="line">                <span class="string">"Unto his nest again,"</span>,</div><div class="line">                <span class="string">"I shall not live in vain"</span>&#125;;</div><div class="line"></div><div class="line">        Runnable runnable = () -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(String message: messages) &#123;</div><div class="line">                System.out.println(message);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">2000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line"></div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Output</div><div class="line">Inside : main</div><div class="line">Inside : Thread-0</div><div class="line">If I can stop one heart from breaking,</div><div class="line">I shall not live in vain.</div><div class="line">If I can ease one life the aching,</div><div class="line">Or cool one pain,</div><div class="line">Or help one fainting robin</div><div class="line">Unto his nest again,</div><div class="line">I shall not live in vain</div></pre></td></tr></table></figure>
<p>当有线程中断了当前线程的执行，<em>sleep()</em>方法会抛出<code>InterruptedException</code>。该异常是checked exception，必须被处理。</p>
<h3 id="Waiting-for-completion-of-another-thread-using-join"><a href="#Waiting-for-completion-of-another-thread-using-join" class="headerlink" title="Waiting for completion of another thread using join()"></a>Waiting for completion of another thread using join()</h3><p><code>join()</code>方法允许一个线程等待另一个线程的完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// Create Thread 1</span></div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Entered Thread 1"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"Exiting Thread 1"</span>);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">// Create Thread 2</span></div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"Entered Thread 2"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">4000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"Exiting Thread 2"</span>);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Starting Thread 1"</span>);</div><div class="line">        thread1.start();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Waiting for Thread 1 to complete"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            thread1.join(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Waited enough! Starting Thread 2 now"</span>);</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Starting Thread 1</div><div class="line">Waiting for Thread 1 to complete</div><div class="line">Entered Thread 1</div><div class="line">Waited enough! Starting Thread 2 now</div><div class="line">Entered Thread 2</div><div class="line">Exiting Thread 1</div><div class="line">Exiting Thread 2</div></pre></td></tr></table></figure>
<p>需要注意：</p>
<ul>
<li><code>Thread.join()</code>等待的真实时间是min(线程终止所需时间，方法参数指明的时间)。</li>
<li><code>join()</code>可以无参数，会一直等待直到线程死亡。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Creating-and-Strating-a-Thread&quot;&gt;&lt;a href=&quot;#Creating-and-Strating-a-Thread&quot; class=&quot;headerlink&quot; title=&quot;Creating and Strating a Thread&quot;&gt;&lt;/a&gt;Creating and Strating a Thread&lt;/h3&gt;&lt;p&gt;Java有两种方式创建线程。&lt;/p&gt;
&lt;h4 id=&quot;1-By-extending-Thread-class&quot;&gt;&lt;a href=&quot;#1-By-extending-Thread-class&quot; class=&quot;headerlink&quot; title=&quot;1. By extending Thread class&quot;&gt;&lt;/a&gt;1. By extending Thread class&lt;/h4&gt;&lt;p&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，重载&lt;code&gt;run()&lt;/code&gt;方法。&lt;code&gt;run()&lt;/code&gt;方法中是该线程的执行逻辑。当创建好之后，通过&lt;code&gt;start()&lt;/code&gt;方法来启动它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="concurrency" scheme="http://houjp.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency之Concurency Basics</title>
    <link href="http://houjp.com/2018/01/28/java-concurrency-basics/"/>
    <id>http://houjp.com/2018/01/28/java-concurrency-basics/</id>
    <published>2018-01-28T07:55:07.000Z</published>
    <updated>2018-01-28T09:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Concurrency is the ability to do more than one thing at the same time.</em></p>
<p><em>Concurrency</em>包含两种情况：</p>
<ol>
<li>同时运行多个应用。</li>
<li>单个应用的多个部分同时执行。</li>
</ol>
<a id="more"></a>
<h3 id="Concurrency-Under-the-Hood"><a href="#Concurrency-Under-the-Hood" class="headerlink" title="Concurrency: Under the Hood"></a>Concurrency: Under the Hood</h3><p>我们都知道计算机可以同时运行multiple tasks，但是这是怎么做到的呢？如今的计算机有multiple processors，如果一个计算机只有一个processor的话可以达到concurrency的目的吗？实际上，计算机可以执行的tasks的数量跟processors的数量之间没有直接的关系。</p>
<p>那么，multiple tasks是如何同时运行在单个CPU上的呢？Multiple tasks并不是真正地在相同的时刻同时执行，它与<em>parallel</em>的概念不同。</p>
<p>当我们说，“multiple tasks are executing at the same time”的时候，这句话的真实含义是“multiple tasks are making progress during the same period of time”。这些tasks的执行是交错进行的。操作系统在tasks之间频繁切换，这样在我们看来这些tasks好像是同时在执行一样。</p>
<p>因此，<em>concurrency</em>与<em>parallelism</em>不同。事实上，<em>parallelism</em>是不可能在单个processor上实现的。</p>
<h3 id="Unit-of-Concurrency"><a href="#Unit-of-Concurrency" class="headerlink" title="Unit of Concurrency"></a>Unit of Concurrency</h3><p><em>Concurrency</em>是一个较为宽泛的概念，它分为不同的层级：</p>
<ul>
<li><strong>Multiprocessing</strong> 多个processors/CPUs同时执行。这里并发的单位是CPU。</li>
<li><strong>Multitasking</strong> 多个tasks/processes在单个CPU上同时执行。操作系统通过在这些tasks之间频繁切换来执行他们。这里并发的单位是process。</li>
<li><strong>Multithreading</strong> 相同program的不同部分同时执行。这里，我们将同样的program分为不同的部分/线程，并且将他们并发的执行。</li>
</ul>
<h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p><em>A process is a program in execution. It has its own address space, a call stack, and link to any resources such as open files.</em></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p><em>A thread is a path of execution within a process.</em> 每个process至少有一个thread, 称为main thread。Main thread可以创建该Process的其他threads。</p>
<p>一个process的所有threads共享这个process的资源，包括memory和open files。但是，每个thread有它自己的call stack。</p>
<p>因为threads共享process的地址空间，因此创建新的threads和threads之间通信会很高效。</p>
<h3 id="Common-Problems-associated-with-Concurrency"><a href="#Common-Problems-associated-with-Concurrency" class="headerlink" title="Common Problems associated with Concurrency"></a>Common Problems associated with Concurrency</h3><p>Concurrency可以提高CPU的利用率(<font color="red">TODO Why?</font>)，但是带来了如下问题：</p>
<ul>
<li><p><strong>Thread interference errors (Race Conditions)</strong>: 这种情况在多个线程同时读写共享变量时发生，并且读写操作之间发生了重叠。</p>
<p>这会造成结果的不可预见性（取决于读写操作的顺序）。</p>
<p>这种情况可以通过加exclusive lock来解决。这会带来新的问题<strong>deadlock</strong>和<strong>starvation</strong>。</p>
</li>
<li><p><strong>Memory consistency errors</strong>: 它指的是不同的线程对于相同的数据产生了inconsistent views。发生的原因是有的线程更新的共享数据，但是没有传播给其他线程，导致这些线程还在用旧数据。</p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.callicoder.com/java-concurrency-multithreading-basics/" target="_blank" rel="external">Java Concurrency / Multithreading Basics</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Concurrency is the ability to do more than one thing at the same time.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concurrency&lt;/em&gt;包含两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同时运行多个应用。&lt;/li&gt;
&lt;li&gt;单个应用的多个部分同时执行。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="concurrency" scheme="http://houjp.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Guice Notes</title>
    <link href="http://houjp.com/2018/01/18/guice/"/>
    <id>http://houjp.com/2018/01/18/guice/</id>
    <published>2018-01-18T15:26:22.000Z</published>
    <updated>2018-01-21T10:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Guice是一个轻量级的依赖注入(DI)框架。它减轻了对<code>factories</code>以及<code>new</code>的使用，我们可以把Guice视为另一种<code>new</code>。在某些时候依然需要写<code>factories</code>，但是代码不需要直接依赖它们。使用Guice有以下好处：</p>
<ol>
<li>易于改变</li>
<li>易于单元测试</li>
<li>易于复用</li>
</ol>
<a id="more"></a>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><h4 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h4><p>DI是一种设计模型，核心原则是<em>separate behaviour from dependency resolution</em>。比如说，<code>RealBillingService</code>不负责查找对<code>TransactionLog</code>和<code>CredictCardProcessor</code>的依赖，这些依赖通过构造函数被传入。这样：</p>
<ol>
<li>依赖就在<em>API signature</em>这一层面上被暴露出来了。</li>
<li>当依赖增加或者减少时，编译器会告诉我们哪些tests需要被修复。</li>
</ol>
<p>接下来，依赖<code>BillingService</code>的类需要在他们的构造函数中接收<code>BillingService</code>。对于最高层的类来说，最好能有一个框架来帮助解决依赖关系，否则就需要递归的在构造函数中传递依赖。这也就是<strong>Guice</strong>存在的意义。</p>
<h4 id="Dependency-Injection-with-Guice"><a href="#Dependency-Injection-with-Guice" class="headerlink" title="Dependency Injection with Guice"></a>Dependency Injection with Guice</h4><p>DI模式可以让代码模块化和易于测试，而Guice让这一切变得容易实现。使用Guice需要以下几个步骤：</p>
<ol>
<li><p>告诉Guice从interfaces到implementations的映射关系。这个配置是在Guide的module中完成的，也就是某个实现<code>Module</code>接口的Java类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> configure &#123;</div><div class="line">    bind(TransactionLog.class).to(DatabaseTransactionLog.class);</div><div class="line">    bind(CredictCardProcessor.class).to(PaypalCreditCardProcessor.class);</div><div class="line">    bind(BillingService.class).to(RealBillingService.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>RealBillingService</code>的构造函数中添加<code>@Inject</code>注解。Guice会检查含有注解的构造函数，并为每个参数查找对应值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CreditCardProcessor processor;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionLog transactionLog;</div><div class="line">  </div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(CredictCardProcessor processor, TransactionLog transactionLog)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.processor = processor;</div><div class="line">    <span class="keyword">this</span>.transactionLog = transactionLog;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后，通过<code>Injector</code>来获取经过绑定的类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Injector injector = Guice.createInjector(<span class="keyword">new</span> BillingModule());</div><div class="line">  BillingService billinService = injector.getInstance(BillingService.class);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样，我们通过Guice构建了一个小的有向无环图，这个图中包含了billing service和它的依赖。</p>
<h3 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h3><p>Injector的任务就是将对象组装成一个有向无环图。当请求一个对象的实例时，Injector会去查找和解决所需要的依赖。为了说明依赖的对象如何被创建，我们需要使用bindings来配置Injector。</p>
<h4 id="Creating-Bindings"><a href="#Creating-Bindings" class="headerlink" title="Creating Bindings"></a>Creating Bindings</h4><p>为了创建bindings，需要继承<code>AbstractModule</code>并重载<code>configure</code>方法，并在函数体中调用<code>bind()</code>方法来指明binding。创建好modules之后，将它作为参数传递给<code>Guice.createInjector()</code>来创建一个injector。</p>
<h4 id="Linked-Bindings"><a href="#Linked-Bindings" class="headerlink" title="Linked Bindings"></a>Linked Bindings</h4><p>Linked bindings将一个type映射为它的implementation。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    bind(TransactionLog.class).to(DatabaseTransactionLog.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，当我们调用<code>injector.getInstance(TransactionLog.class)</code>，或者当injector遇到对<code>TransactionLog</code>的依赖时，它将会使用<code>DatabaseTransactionLog</code>。将type映射到任何一个它的subtypes（比如一个implementing class或者一个extending class）。你甚至可以将一个具体的<code>DatabaseTransactionLog</code>类映射到它的子类上去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class);</div></pre></td></tr></table></figure>
<p>Linked bindings也可以被串成一条链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    bind(TransactionLog.class).to(DatabaseTransactionLog.class);</div><div class="line">    bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，当需要<code>TransactionLog</code>时，injector将会提供<code>MySqlDatabaseTransactionLog</code>。       </p>
<h4 id="Binding-Annotations"><a href="#Binding-Annotations" class="headerlink" title="Binding Annotations"></a>Binding Annotations</h4><p>有时候你想要对某个type实现多个绑定，比如，你希望同时存在一个PayPal credit card processor和一个Google Checkout processor。Guice支持可选的<em>binding annotation</em>。<em>annotation</em>和<em>type</em>共同决定了一个唯一的binding。这个pair称为key。</p>
<p><em>binding annotation</em>可以定义在单独的<code>.java</code>文件中，可以在它所注解的type定义中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> example.pizza;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.google.inject.BindingAnnotation;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Target;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.PARAMETER;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.FIELD;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</div><div class="line"></div><div class="line"><span class="meta">@BindingAnnotation</span> <span class="meta">@Target</span>(&#123; FIELD, PARAMETER, METHOD &#125;) <span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayPal &#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>@BindingAnnotation</code>告诉Guice这是一个binding annotation。如果一个成员有多个binding annotations，Guice将会报错。</li>
<li><code>@Target({FIELD, PARAMETER, METHOD})</code>是对使用者的礼貌性声明。它可以阻止<code>@PayPal</code>被意外使用在它不希望被使用的地方。</li>
<li><code>@Retention(RUNTIME)</code>使得annotation在runtime时可被使用。</li>
</ul>
<p>当被注入参数需要annotated binding时，需要进行申明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@PayPal CreditCardProcessor processor,</span></span></div><div class="line"><span class="function"><span class="params">      TransactionLog transactionLog)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>最后，在binding时，使用<code>bind()</code>方法中可选的<code>annotatedWith</code>从句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bind(CreditCardProcessor.class)</div><div class="line">    .annotatedWith(PayPal.class)</div><div class="line">    .to(PayPalCreditCardProcessor.class);</div></pre></td></tr></table></figure>
<h5 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h5><p>Guice提供了一个build-in binding annotation <code>@Named</code>，它需要一个string的输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(@Named(<span class="string">"Checkout"</span>)</span> CreditCardProcessor processor,</span></div><div class="line"><span class="function">      TransactionLog transactionLog) </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>对应的在<code>build()</code>方法中，使用<code>Names.named()</code>创建一个实例并传给<code>annotatedWith</code>从句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bind(CreditCardProcessor.class)</div><div class="line">        .annotatedWith(Names.named(<span class="string">"Checkout"</span>))</div><div class="line">        .to(CheckoutCreditCardProcessor.class);</div></pre></td></tr></table></figure>
<p>但是，compiler不会检查这个string，所以尽量少的使用<code>@Named</code>。定义自己的purpose-build annotations更符合type-safety。</p>
<h4 id="Instance-Bindings"><a href="#Instance-Bindings" class="headerlink" title="Instance Bindings"></a>Instance Bindings</h4><p>我们可以将type绑定为一个特定的实例。这通常用在内部没有其他依赖的对象中，比如value objects:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bind(String.class)</div><div class="line">    .annotatedWith(Names.named(<span class="string">"JDBC URL"</span>))</div><div class="line">    .toInstance(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</div><div class="line">bind(Integer.class)</div><div class="line">    .annotatedWith(Names.named(<span class="string">"login timeout seconds"</span>))</div><div class="line">    .toInstance(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>避免对构建复杂的objects使用<code>.toInstance</code>，这将会拖累应用的启动。这种情况应该使用<code>@Provides</code>。</p>
<h4 id="Provides-Methods"><a href="#Provides-Methods" class="headerlink" title="@Provides Methods"></a>@Provides Methods</h4><p>当需要代码来创建一个object的时候，使用<code>@Provides</code>方法。它需要在module中定义，并且含有<code>@Provides</code>注解。方法的返回类型是被绑定的类型。当injector需要这个类型时，就会调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Provides</span></div><div class="line">  <span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</div><div class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</div><div class="line">    transactionLog.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/pizza"</span>);</div><div class="line">    transactionLog.setThreadPoolSize(<span class="number">30</span>);</div><div class="line">    <span class="keyword">return</span> transactionLog;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以在<code>@Provides</code>方法中使用像<code>@PayPal</code>或者<code>@Named(&quot;&quot;Checkout)</code>之类的binding annotation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provides</span> <span class="meta">@PayPal</span></div><div class="line"> <span class="function">CreditCardProcessor <span class="title">providePayPalCreditCardProcessor</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">     @Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</div><div class="line">   PayPalCreditCardProcessor processor = <span class="keyword">new</span> PayPalCreditCardProcessor();</div><div class="line">   processor.setApiKey(apiKey);</div><div class="line">   <span class="keyword">return</span> processor;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h5><p>Guice不允许Providers中抛出异常。<code>@Provides</code>中抛出的异常会被包装成<code>ProvisionException</code>。如果一定要抛出异常，请使用<code>@CheckedProvides</code>方法。</p>
<h4 id="Provider-Bindings"><a href="#Provider-Bindings" class="headerlink" title="Provider Bindings"></a>Provider Bindings</h4><p>当<code>@Provides</code>方法变得复杂的时候，可以考虑为其生成一个单独的类。这个provider类实现了Guice的<code>Provider</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下实现的provider类有它自己的依赖，并通过<code>@Inject</code>-annotated constructor来接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLogProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DatabaseTransactionLogProvider</span><span class="params">(Connection connection)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.connection = connection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> TransactionLog <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    DatabaseTransactionLog transactionLog = <span class="keyword">new</span> DatabaseTransactionLog();</div><div class="line">    transactionLog.setConnection(connection);</div><div class="line">    <span class="keyword">return</span> transactionLog;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在绑定时使用<code>.toProvider</code>从句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    bind(TransactionLog.class)</div><div class="line">        .toProvider(DatabaseTransactionLogProvider.class);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>当providers的逻辑复杂时，需要对其进行测试。</p>
<h5 id="Throwing-Exceptions-1"><a href="#Throwing-Exceptions-1" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h5><p>Guice不允许providers抛出异常。RuntimeExceptions可能被包装成<code>ProvisionException</code>或者<code>CreationException</code>。如果一定要抛出异常，请使用ThrowingProviders extension。</p>
<h4 id="Untargeted-Bindings"><a href="#Untargeted-Bindings" class="headerlink" title="Untargeted Bindings"></a>Untargeted Bindings</h4><p>我们可以创建不指定目标的bindings。当具体的类或者类型通过<code>@ImplementedBy</code>或者<code>@ProvidedBy</code>被注解时，使用这种绑定。</p>
<blockquote>
<p><font color="red">TODO</font> 什么情况下/为什么用untargeted bindings</p>
</blockquote>
<p>Untargeted bindings没有<code>to</code>从句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bind(MyConcreteClass.class);</div><div class="line">bind(AnotherConcreteClass.class).in(Singleton.class);</div></pre></td></tr></table></figure>
<p>当要指明binding annotations时，需要在<code>bind()</code>方法中添加一个相同的绑定目标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bind(MyConcreteClass.class)</div><div class="line">    .annotatedWith(Names.named(<span class="string">"foo"</span>))</div><div class="line">    .to(MyConcreteClass.class);</div><div class="line">bind(AnotherConcreteClass.class)</div><div class="line">    .annotatedWith(Names.named(<span class="string">"foo"</span>))</div><div class="line">    .to(AnotherConcreteClass.class)</div><div class="line">    .in(Singleton.class);</div></pre></td></tr></table></figure>
<h4 id="Constructor-Bindings"><a href="#Constructor-Bindings" class="headerlink" title="Constructor Bindings"></a>Constructor Bindings</h4><p>有时候需要绑定一个type到任意一个constructor。<code>@Inject</code>注解在这种情况无法使用：1)这个构造函数可能属于一个第三方的类，2)这个类有多个构造函数，DI不知道该使用哪个。<code>@Provides</code>方法通过显示调用构造函数可以很好的解决这个问题。但是这种方法有局限性：手动构造实例不参与<code>AOP</code>。</p>
<blockquote>
<p><font color="red">TODO</font> AOP是什么</p>
</blockquote>
<p>为了解决这个问题，Guice提供了<code>toConstructor()</code>绑定。它要求我们选择需要的构造函数并处理constructor找不到时的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillingModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      bind(TransactionLog.class).toConstructor(</div><div class="line">          DatabaseTransactionLog.class.getConstructor(DatabaseConnection.class));</div><div class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">      addError(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>DatabaseTransactionLog</code>必须含有一个接受单个<code>DatabaseConnection</code>参数的构造器。这个构造器不需要<code>@Inject</code>注解。Guice会调用满足绑定条件的constructor。</p>
<p>每个<code>toConstructor()</code>绑定是范围独立的。如果你创建了多个目标构造器相同的singleton绑定，每个绑定会产生它自己的实例。</p>
<h4 id="Built-in-Bindings"><a href="#Built-in-Bindings" class="headerlink" title="Built-in Bindings"></a>Built-in Bindings</h4><blockquote>
<p><font color="red">TODO</font> More bindings we can use</p>
</blockquote>
<h4 id="Just-In-Time-Bindings"><a href="#Just-In-Time-Bindings" class="headerlink" title="Just-In-Time Bindings"></a>Just-In-Time Bindings</h4><p>当injector需要某个类型的实例时，就需要对应的绑定。Modules中的绑定成为<em>explicit bindings</em>，当它们available的时候injector就会使用它们。如果需要某种类型但是explicit bindings中没有时，injector会尝试创建<em>Just-In-Time binding</em>，这也被称为<em>JIT bindings</em>和<em>implicit bindings</em>。</p>
<h5 id="Eligible-Constructors"><a href="#Eligible-Constructors" class="headerlink" title="Eligible Constructors"></a>Eligible Constructors</h5><p>Guice可以为具体类型创建bindings，通过使用该类型的<em>injectable constructor</em>。这个constructor可以是non-private, no-arguments constructor，也可以是带有<code>@Inject</code>注解的constructor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPalCreditCardProcessor</span> <span class="keyword">implements</span> <span class="title">CreditCardProcessor</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String apiKey;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PayPalCreditCardProcessor</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.apiKey = apiKey;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><font color="red">TODO</font> Guice如何为<em>nested class</em>和<em>inner classes</em>创建JIT bindings?</p>
</blockquote>
<h5 id="ImplementedBy"><a href="#ImplementedBy" class="headerlink" title="@ImplementedBy"></a>@ImplementedBy</h5><p>经过注解的类型告诉injector它们的默认实现类型是什么。<code>@ImplementedBy</code>注解类似于<em>linked binding</em>，指明了构建类型时使用的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ImplementedBy</span>(PayPalCreditCardProcessor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CreditCardProcessor</span> </span>&#123;</div><div class="line">  <span class="function">ChargeResult <span class="title">charge</span><span class="params">(String amount, CreditCard creditCard)</span></span></div><div class="line"><span class="function">      <span class="keyword">throws</span> UnreachableException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上例子与下面使用<code>bind()</code>的语句等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind(CreditCardProcessor.class).to(PayPalCreditCardProcessor.class);</div></pre></td></tr></table></figure>
<p>如果一个类型同时使用了<code>bind()</code>和<code>@ImplementedBy</code>注解，最终生效的是<code>bind()</code>语句。注解的方式提供了一个<em>default implement</em>，它可以被binding覆盖。需要小心使用<code>@ImplementedBy</code>，它添加了一个从接口到其实现的compile-time dependency。</p>
<h5 id="ProvidedBy"><a href="#ProvidedBy" class="headerlink" title="@ProvidedBy"></a>@ProvidedBy</h5><p><code>ProvidedBy</code>告诉injector这个<code>Provider</code>类来生成实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProvidedBy</span>(DatabaseTransactionLogProvider.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionLog</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">logConnectException</span><span class="params">(UnreachableException e)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">logChargeResult</span><span class="params">(ChargeResult result)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它与<code>toProvider()</code>绑定等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bind(TransactionLog.class)</div><div class="line">    .toProvider(DatabaseTransactionLogProvider.class);</div></pre></td></tr></table></figure>
<p>如果在使用该注解的同时使用了<code>bind()</code>语句，最终生效的是<code>bind()</code>语句。</p>
<h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><p>在默认情况下，Guice会返回一个新的实例。这个行为可以通过<em>scopes</em>进行配置。Scopes允许我们复用生成的实例：</p>
<ul>
<li>application lifetime (<code>@Singleton</code>)</li>
<li>session lifetime (<code>@SessionScoped</code>)</li>
<li>request lifetime (<code>@RequestScoped</code>)</li>
</ul>
<p>Guice包含一套servlet extension，它是为web apps定义的scopes。也可以为其他应用自定义scopes (custom scopes)。</p>
<p>####Applying Scopes</p>
<p>Guices使用annotations来定义scopes。通过对实现类使用scope annotation来指定类型的scope。</p>
<p><code>@Singleton</code>要求类是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</div><div class="line">  <span class="comment">/* everything here should be threadsafe! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scopes可以在<code>bind</code>语句中配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provides</span> <span class="meta">@Singleton</span></div><div class="line"><span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果类型中的scope和<code>bind()</code>语句中的scope冲突，则<code>bind()</code>语句中的scope会被使用。如果type中注解了一个你不希望使用的scope，则可以通过在<code>bind</code>绑定<code>Scopes.NO_SCOPE</code>来覆盖它。</p>
<p>在<em>linked bindings</em>中，scopes在binding source上生效，而不是binding target。举例，加入我们有一个类<code>Applebees</code>实现了<code>Bar</code>和<code>Grill</code>接口。则以下的绑定方法会允许该类型的两个实例，一个给<code>Bar</code>s，另一个给<code>Grill</code>s：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bind(Bar.class).to(Applebees.class).in(Singleton.class);</div><div class="line">bind(Grill.class).to(Applebees.class).in(Singleton.class);</div></pre></td></tr></table></figure>
<p>如果想只生成一个实例，则需要为这个类添加<code>@Singleton</code>注解，或者添加如下的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind(Applebees.class).in(Singleton.class);</div></pre></td></tr></table></figure>
<p><code>in()</code>从句接收两种参数：</p>
<ol>
<li><p>a scoping annotation，如<code>RequestScoped.class</code></p>
</li>
<li><p><code>Scope</code> instances 比如<code>ServletScopes.REQUEST</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bind(UserPreferences.class)</div><div class="line">    .toProvider(UserPreferencesProvider.class)</div><div class="line">    .in(ServletScopes.REQUEST);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Injections"><a href="#Injections" class="headerlink" title="Injections"></a>Injections</h3><h4 id="Injections-1"><a href="#Injections-1" class="headerlink" title="Injections"></a>Injections</h4><p><strong>The dependency injectoin pattern separated behaviour from dependency resolution.</strong> </p>
<p>这种模式要求依赖是传入的，而不是在类中查找依赖或者通过工厂方法导入。为对象设置依赖的过程称为<em>injection</em>。</p>
<h5 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h5><p>Constructor injection将实例化与injection相结合。需要给constructor添加<code>@Inject</code>注解，并在参数中接收类的依赖。大多数constructor会将这些参数赋值给final fields：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBillingService</span> <span class="keyword">implements</span> <span class="title">BillingService</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CreditCardProcessor processorProvider;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionLog transactionLogProvider;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealBillingService</span><span class="params">(CreditCardProcessor processorProvider,</span></span></div><div class="line"><span class="function"><span class="params">      TransactionLog transactionLogProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.processorProvider = processorProvider;</div><div class="line">    <span class="keyword">this</span>.transactionLogProvider = transactionLogProvider;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果类中没有经过<code>@Inject</code>注解的constructor，Guice将会使用一个public, no-arguments constructor (if exists)。最好使用注解，这样可以显示申明这个类型参与了DI。</p>
<p>Constructor injection对于unit testing非常友好：</p>
<ol>
<li>如果类通过单个constructor接收它的所有依赖，那么我们不会忘记去设置依赖。</li>
<li>如果新增加了依赖，那么涉及到的测试代码会break掉，很直接的提示我们去fix这些compile errors。</li>
</ol>
<h5 id="Method-Injection"><a href="#Method-Injection" class="headerlink" title="Method Injection"></a>Method Injection</h5><p>Guice也可以将依赖注入到方法中，如果方法含有<code>@Inject</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPalCreditCardProcessor</span> <span class="keyword">implements</span> <span class="title">CreditCardProcessor</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_API_KEY = <span class="string">"development-use-only"</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> String apiKey = DEFAULT_API_KEY;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApiKey</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.apiKey = apiKey;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Field-Injection"><a href="#Field-Injection" class="headerlink" title="Field Injection"></a>Field Injection</h5><p>Guice会注入含有<code>@Inject</code>注解的fields。很简洁，但是对test很不友好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLogProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@Inject</span> Connection connection;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> TransactionLog <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DatabaseTransactionLog(connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>避免对<code>final</code> fields使用<em>field injection</em> (因为 <em>weak semantics</em>)。</p>
<blockquote>
<p><font color="red">TODO</font> 什么是weak semantics?</p>
</blockquote>
<h5 id="Optional-Injections"><a href="#Optional-Injections" class="headerlink" title="Optional Injections"></a>Optional Injections</h5><p>Method injections和fields injections可以设置为可选的，这样使得当dependencies不存在的时候Guice会silently ignore这些依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPalCreditCardProcessor</span> <span class="keyword">implements</span> <span class="title">CreditCardProcessor</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SANDBOX_API_KEY = <span class="string">"development-use-only"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String apiKey = SANDBOX_API_KEY;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span>(optional=<span class="keyword">true</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApiKey</span><span class="params">(@Named(<span class="string">"PayPal API key"</span>)</span> String apiKey) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.apiKey = apiKey;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Optional injection和just-in-time bindings混用时需要格外留心。例如，以下情况在<code>Date</code>没有显式绑定时意外会被注入。因为<code>Date</code>有一个public no-arguments constructor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span>(optional=<span class="keyword">true</span>) Date launchDate;</div></pre></td></tr></table></figure>
<h4 id="On-demand-Injection"><a href="#On-demand-Injection" class="headerlink" title="On-demand Injection"></a>On-demand Injection</h4><p>Method injection和field injection可以被用来初始化一个已经存在的实例。你可以通过<code>Injector.injectMembers</code> API来实现这一目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Injector injector = Guice.createInjector(...);</div><div class="line">  </div><div class="line">  CreditCardProcessor creditCardProcessor = <span class="keyword">new</span> PayPalCreditCardProcessor();</div><div class="line">  injector.injectMembers(creditCardProcessor);</div></pre></td></tr></table></figure>
<h4 id="Static-Injections"><a href="#Static-Injections" class="headerlink" title="Static Injections"></a>Static Injections</h4><blockquote>
<p><font color="red">TODO</font> 不是很明白</p>
</blockquote>
<h4 id="Automatic-Injection"><a href="#Automatic-Injection" class="headerlink" title="Automatic Injection"></a>Automatic Injection</h4><p>Guice会自动注入下列这些：</p>
<ul>
<li><code>bind</code>语句中传递给<code>toInstance()</code>的实例。</li>
<li><code>bind</code>语句中传递给<code>toProvider()</code>的provider instances。</li>
</ul>
<h4 id="Injecting-Providers"><a href="#Injecting-Providers" class="headerlink" title="Injecting Providers"></a>Injecting Providers</h4><p>当你想要为依赖的类型生成多个实例时，可以使用Guice的provider。Providers在每次调用<code>get()</code>方法时产生一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Provider-for-multiple-instances"><a href="#Provider-for-multiple-instances" class="headerlink" title="Provider for multiple instances"></a>Provider for multiple instances</h5><p>当同种类型需要产生多个实例时，使用providers:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFileTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;LogFileEntry&gt; logFileProvider;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LogFileTransactionLog</span><span class="params">(Provider&lt;LogFileEntry&gt; logFileProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.logFileProvider = logFileProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logChargeResult</span><span class="params">(ChargeResult result)</span> </span>&#123;</div><div class="line">    LogFileEntry summaryEntry = logFileProvider.get();</div><div class="line">    summaryEntry.setText(<span class="string">"Charge "</span> + (result.wasSuccessful() ? <span class="string">"success"</span> : <span class="string">"failure"</span>));</div><div class="line">    summaryEntry.save();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!result.wasSuccessful()) &#123;</div><div class="line">      LogFileEntry detailEntry = logFileProvider.get();</div><div class="line">      detailEntry.setText(<span class="string">"Failure result: "</span> + result);</div><div class="line">      detailEntry.save();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Providers-for-lazy-loading"><a href="#Providers-for-lazy-loading" class="headerlink" title="Providers for lazy loading"></a>Providers for lazy loading</h5><p>当某种依赖生成实例的代价非常昂贵时，可以使用provider来推迟实例的生成。当不经常使用该依赖时，使用providers会非常有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;Connection&gt; connectionProvider;</div><div class="line"></div><div class="line">  <span class="meta">@Inject</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DatabaseTransactionLog</span><span class="params">(Provider&lt;Connection&gt; connectionProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.connectionProvider = connectionProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logChargeResult</span><span class="params">(ChargeResult result)</span> </span>&#123;</div><div class="line">    <span class="comment">/* only write failed charges to the database */</span></div><div class="line">    <span class="keyword">if</span> (!result.wasSuccessful()) &#123;</div><div class="line">      Connection connection = connectionProvider.get();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Providers-for-Mixing-Scopes"><a href="#Providers-for-Mixing-Scopes" class="headerlink" title="Providers for Mixing Scopes"></a>Providers for Mixing Scopes</h5><p>依赖于一个narrower scope的对象是错误的行为。假设有一个singleton transanction log需要request-scoped current user。直接注入user是错误的，因为不同的request对应的user是不同的。这时候应该使用providers来通过调用<code>get()</code>方法来产生实例，保证mix scopes safely:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Singleton</div><div class="line">public class ConsoleTransactionLog implements TransactionLog &#123;</div><div class="line">  </div><div class="line">  private final AtomicInteger failureCount = new AtomicInteger();</div><div class="line">  private final Provider&lt;User&gt; userProvider;</div><div class="line"></div><div class="line">  @Inject</div><div class="line">  public ConsoleTransactionLog(Provider&lt;User&gt; userProvider) &#123;</div><div class="line">    this.userProvider = userProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void logConnectException(UnreachableException e) &#123;</div><div class="line">    failureCount.incrementAndGet();</div><div class="line">    User user = userProvider.get();</div><div class="line">    System.out.println(&quot;Connection failed for &quot; + user + &quot;: &quot; + e.getMessage());</div><div class="line">    System.out.println(&quot;Failure count: &quot; + failureCount.incrementAndGet());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="Aspect-Oriented-Programming"><a href="#Aspect-Oriented-Programming" class="headerlink" title="Aspect Oriented Programming"></a>Aspect Oriented Programming</h4><p>Guice支持<em>method interception</em>。它使得当一个<em>matching</em>方法被调用时执行我们额外补充的代码。因为interceptors将问题切分成了aspects，而不是对象，所以称为Aspect Oriented Programming (AOP)。</p>
<p>Guice官网提供了一个<strong>Forbidding method calls on weekends</strong>的<a href="https://github.com/google/guice/wiki/AOP#example-forbidding-method-calls-on-weekends" target="_blank" rel="external">示例</a>。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] <a href="https://github.com/google/guice" target="_blank" rel="external">google/guice</a></p>
<p>[2] <a href="http://ot-note.logdown.com/posts/208733/interface-and-abstract-class-different-from-the-concrete-class" target="_blank" rel="external">Interface, Abstract Class和Concrete Class的区别</a></p>
<h3 id="More-Questions"><a href="#More-Questions" class="headerlink" title="More Questions"></a>More Questions</h3><p>[1] Java中<code>extends</code>和<code>implements</code>的区别</p>
<p>[2] Java中<code>nested classes</code>和<code>inner classes</code>的区别</p>
<p>[3] Java中的<code>threadsafe</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h3&gt;&lt;p&gt;Guice是一个轻量级的依赖注入(DI)框架。它减轻了对&lt;code&gt;factories&lt;/code&gt;以及&lt;code&gt;new&lt;/code&gt;的使用，我们可以把Guice视为另一种&lt;code&gt;new&lt;/code&gt;。在某些时候依然需要写&lt;code&gt;factories&lt;/code&gt;，但是代码不需要直接依赖它们。使用Guice有以下好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;易于改变&lt;/li&gt;
&lt;li&gt;易于单元测试&lt;/li&gt;
&lt;li&gt;易于复用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="guice" scheme="http://houjp.com/tags/guice/"/>
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Unit Test中的Mock Objects</title>
    <link href="http://houjp.com/2018/01/07/mock-objects/"/>
    <id>http://houjp.com/2018/01/07/mock-objects/</id>
    <published>2018-01-07T04:10:18.000Z</published>
    <updated>2018-01-07T14:39:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What’s-Mock-Objects"><a href="#What’s-Mock-Objects" class="headerlink" title="What’s Mock Objects"></a>What’s Mock Objects</h3><p>Mock objects 是 test double 的另一种称呼，包含以下三种类型的对象：</p>
<ol>
<li>Mocks</li>
<li>Stubs</li>
<li>Fakes</li>
</ol>
<a id="more"></a>
<h4 id="Mocks"><a href="#Mocks" class="headerlink" title="Mocks"></a>Mocks</h4><p>Mock在单元测试中用来追踪对象的方法是否被正确调用：</p>
<ol>
<li>方法的调用次数是否符合预期</li>
<li>传递给方法的参数是否正确</li>
</ol>
<h4 id="Stubs"><a href="#Stubs" class="headerlink" title="Stubs"></a>Stubs</h4><p>当我们不需要知道对象内部的行为情况的时候使用Stub对象，它会返回我们告诉它返回的值。</p>
<h4 id="Fakes"><a href="#Fakes" class="headerlink" title="Fakes"></a>Fakes</h4><p>Fake是对API的轻量级实现，不适用于真正的产品。</p>
<h3 id="Testing-State-VS-Testing-Interactions"><a href="#Testing-State-VS-Testing-Interactions" class="headerlink" title="Testing State VS Testing Interactions"></a>Testing State VS Testing Interactions</h3><p>在单元测试中有两种测试的方式：</p>
<ol>
<li>Testing state: 测试代码返回的结果的正确性<ul>
<li>返回结果正确</li>
<li>系统中状态值正确改变</li>
</ul>
</li>
<li>Testing interactions: 代码调用了希望被调用的某些方法<ul>
<li>方法是否被调用</li>
<li>传递给被调用方法的参数是否正确</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>Testing interactions只能保证函数被正确调用，Testing state才能真正保证结果的正确性。</li>
<li>Testing interactions不利于测试代码的维护。</li>
</ul>
<h3 id="测试三步曲"><a href="#测试三步曲" class="headerlink" title="测试三步曲"></a>测试三步曲</h3><p>单元测试分为三个阶段：</p>
<ol>
<li>Arrange: 测试条件准备阶段，也就是”Given”。</li>
<li>Act: 执行阶段，调用测试方法，也就是”When”。</li>
<li>Assert: 判断结果，也就是”Then”。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What’s-Mock-Objects&quot;&gt;&lt;a href=&quot;#What’s-Mock-Objects&quot; class=&quot;headerlink&quot; title=&quot;What’s Mock Objects&quot;&gt;&lt;/a&gt;What’s Mock Objects&lt;/h3&gt;&lt;p&gt;Mock objects 是 test double 的另一种称呼，包含以下三种类型的对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mocks&lt;/li&gt;
&lt;li&gt;Stubs&lt;/li&gt;
&lt;li&gt;Fakes&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://houjp.com/tags/java/"/>
    
      <category term="unit-testing" scheme="http://houjp.com/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>深度学习(Deep Learning)学习资料</title>
    <link href="http://houjp.com/2017/08/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Deep-Learning-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>http://houjp.com/2017/08/25/深度学习-Deep-Learning-学习资料/</id>
    <published>2017-08-25T07:53:08.000Z</published>
    <updated>2018-04-14T12:37:27.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h3><ul>
<li><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="external">Deep Learning Specialization</a><ul>
<li>Neural Networks and Deep Learning</li>
<li>Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization</li>
<li>Structuring Machine Learning Projects</li>
<li>Convolutional Neural Networks</li>
<li>Sequence Models</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ul>
<li>矩阵<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24709748" target="_blank" rel="external">矩阵求导术（上）</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;公开课&quot;&gt;&lt;a href=&quot;#公开课&quot; class=&quot;headerlink&quot; title=&quot;公开课&quot;&gt;&lt;/a&gt;公开课&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coursera.org/specializations/deep-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deep Learning Specialization&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Neural Networks and Deep Learning&lt;/li&gt;
&lt;li&gt;Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization&lt;/li&gt;
&lt;li&gt;Structuring Machine Learning Projects&lt;/li&gt;
&lt;li&gt;Convolutional Neural Networks&lt;/li&gt;
&lt;li&gt;Sequence Models&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://houjp.com/tags/deep-learning/"/>
    
  </entry>
  
</feed>
